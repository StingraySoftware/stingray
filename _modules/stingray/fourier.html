<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.fourier &#8212; stingray v2.3.0</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-astropy.css?v=177ce38d" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=17ab1725" />
    
    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=c3c8ae58"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="icon" href="../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">stingray v2.3.0</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.fourier</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.table</span><span class="w"> </span><span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.timeseries.periodograms.lombscargle.implementations.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">trig_sum</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.gti</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">generate_indices_of_segment_boundaries_binned</span><span class="p">,</span>
    <span class="n">generate_indices_of_segment_boundaries_unbinned</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">fft</span><span class="p">,</span>
    <span class="n">fftfreq</span><span class="p">,</span>
    <span class="n">histogram</span><span class="p">,</span>
    <span class="n">show_progress</span><span class="p">,</span>
    <span class="n">sum_if_not_none_or_initialize</span><span class="p">,</span>
    <span class="n">fix_segment_size_to_integer_samples</span><span class="p">,</span>
    <span class="n">rebin_data</span><span class="p">,</span>
    <span class="n">njit</span><span class="p">,</span>
    <span class="n">vectorize</span><span class="p">,</span>
    <span class="n">float64</span><span class="p">,</span>
    <span class="n">int64</span><span class="p">,</span>
    <span class="n">UniTuple</span><span class="p">,</span>
<span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;integrate_power_in_frequency_range&quot;</span><span class="p">,</span>
    <span class="s2">&quot;positive_fft_bins&quot;</span><span class="p">,</span>
    <span class="s2">&quot;poisson_level&quot;</span><span class="p">,</span>
    <span class="s2">&quot;normalize_frac&quot;</span><span class="p">,</span>
    <span class="s2">&quot;normalize_abs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;normalize_leahy_from_variance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;normalize_leahy_poisson&quot;</span><span class="p">,</span>
    <span class="s2">&quot;normalize_periodograms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;unnormalize_periodograms&quot;</span><span class="p">,</span>
    <span class="s2">&quot;bias_term&quot;</span><span class="p">,</span>
    <span class="s2">&quot;raw_coherence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;coherence&quot;</span><span class="p">,</span>
    <span class="s2">&quot;intrinsic_coherence&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="integrate_power_in_frequency_range">
<a class="viewcode-back" href="../../api.html#stingray.fourier.integrate_power_in_frequency_range">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">integrate_power_in_frequency_range</span><span class="p">(</span>
    <span class="n">frequency</span><span class="p">,</span>
    <span class="n">power</span><span class="p">,</span>
    <span class="n">frequency_range</span><span class="p">,</span>
    <span class="n">power_err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">poisson_power</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate the power in a given frequency range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency : iterable</span>
<span class="sd">        The frequencies of the power spectrum</span>
<span class="sd">    power : iterable</span>
<span class="sd">        The power at each frequency</span>
<span class="sd">    frequency_range : iterable of length 2</span>
<span class="sd">        The frequency range to integrate</span>
<span class="sd">    power_err : iterable, optional, default None</span>
<span class="sd">        The power error bar at each frequency</span>
<span class="sd">    df : float or float iterable, optional, default None</span>
<span class="sd">        The frequency resolution of the input data. If None, it is calculated</span>
<span class="sd">        from the median difference of input frequencies.</span>
<span class="sd">    m : int, optional, default 1</span>
<span class="sd">        The number of segments and/or contiguous frequency bins averaged to obtain power.</span>
<span class="sd">        Only needed if ``power_err`` is None</span>
<span class="sd">    poisson_power : float, optional, default 0</span>
<span class="sd">        The Poisson noise level of the power spectrum.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power_integrated : float</span>
<span class="sd">        The integrated power</span>
<span class="sd">    power_integrated_err : float</span>
<span class="sd">        The error on the integrated power</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">power</span><span class="p">):</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">power</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poisson_power</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">poisson_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">poisson_power</span>
    <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span>

    <span class="c1"># The frequency_range is in the middle or at the edge of each bin. When only a part of the</span>
    <span class="c1"># bin is included, we need to add the fraction of the bin that is included.</span>
    <span class="n">frequency_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">frequency</span> <span class="o">+</span> <span class="n">df</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">frequency_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
        <span class="n">frequency</span> <span class="o">-</span> <span class="n">df</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">frequency_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">freqs_to_integrate</span> <span class="o">=</span> <span class="n">frequency</span><span class="p">[</span><span class="n">frequency_mask</span><span class="p">]</span>
    <span class="n">poisson_power</span> <span class="o">=</span> <span class="n">poisson_power</span><span class="p">[</span><span class="n">frequency_mask</span><span class="p">]</span>
    <span class="n">correction_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">freqs_to_integrate</span><span class="p">)</span>
    <span class="n">dfs_to_integrate</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">frequency_mask</span><span class="p">]</span>

    <span class="c1"># The first and last bins are only partially included. We need to correct for the</span>
    <span class="c1"># fraction of the bin actually included.</span>
    <span class="n">correction_ratios</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">freqs_to_integrate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dfs_to_integrate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">frequency_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">dfs_to_integrate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">correction_ratios</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">frequency_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freqs_to_integrate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dfs_to_integrate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">dfs_to_integrate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dfs_to_integrate</span> <span class="o">=</span> <span class="n">dfs_to_integrate</span> <span class="o">*</span> <span class="n">correction_ratios</span>

    <span class="n">powers_to_integrate</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="n">frequency_mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">power_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">power_err_to_integrate</span> <span class="o">=</span> <span class="n">powers_to_integrate</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">power_err_to_integrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">power_err</span><span class="p">)[</span><span class="n">frequency_mask</span><span class="p">]</span>

    <span class="n">power_integrated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">powers_to_integrate</span> <span class="o">-</span> <span class="n">poisson_power</span><span class="p">)</span> <span class="o">*</span> <span class="n">dfs_to_integrate</span><span class="p">)</span>
    <span class="n">power_err_integrated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">power_err_to_integrate</span> <span class="o">*</span> <span class="n">dfs_to_integrate</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">power_integrated</span><span class="p">,</span> <span class="n">power_err_integrated</span></div>



<div class="viewcode-block" id="positive_fft_bins">
<a class="viewcode-back" href="../../api.html#stingray.fourier.positive_fft_bins">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">positive_fft_bins</span><span class="p">(</span><span class="n">n_bin</span><span class="p">,</span> <span class="n">include_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Give the range of positive frequencies of a complex FFT.</span>

<span class="sd">    This assumes we are using Numpy&#39;s FFT, or something compatible</span>
<span class="sd">    with it, like ``pyfftw.interfaces.numpy_fft``, where the positive</span>
<span class="sd">    frequencies come before the negative ones, the Nyquist frequency is</span>
<span class="sd">    included in the negative frequencies but only in even number of bins,</span>
<span class="sd">    and so on.</span>
<span class="sd">    This is mostly to avoid using the ``freq &gt; 0`` mask, which is</span>
<span class="sd">    memory-hungry and inefficient with large arrays. We use instead a</span>
<span class="sd">    slice object, giving the range of bins of the positive frequencies.</span>

<span class="sd">    See https://numpy.org/doc/stable/reference/routines.fft.html#implementation-details</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        The number of bins in the FFT, including all frequencies</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    include_zero : bool, default False</span>
<span class="sd">        Include the zero frequency in the output slice</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    positive_bins : `slice`</span>
<span class="sd">        Slice object encoding the positive frequency bins. See examples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Let us calculate the positive frequencies using the usual mask</span>
<span class="sd">    &gt;&gt;&gt; freq = np.fft.fftfreq(10)</span>
<span class="sd">    &gt;&gt;&gt; good = freq &gt; 0</span>

<span class="sd">    This works well, but it is highly inefficient in large arrays.</span>
<span class="sd">    This function will instead return a `slice object`, which will work</span>
<span class="sd">    as an equivalent mask for the positive bins. Below, a few tests that</span>
<span class="sd">    this works as expected.</span>
<span class="sd">    &gt;&gt;&gt; goodbins = positive_fft_bins(10)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(freq[good], freq[goodbins])</span>
<span class="sd">    &gt;&gt;&gt; freq = np.fft.fftfreq(11)</span>
<span class="sd">    &gt;&gt;&gt; good = freq &gt; 0</span>
<span class="sd">    &gt;&gt;&gt; goodbins = positive_fft_bins(11)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(freq[good], freq[goodbins])</span>
<span class="sd">    &gt;&gt;&gt; freq = np.fft.fftfreq(10)</span>
<span class="sd">    &gt;&gt;&gt; good = freq &gt;= 0</span>
<span class="sd">    &gt;&gt;&gt; goodbins = positive_fft_bins(10, include_zero=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(freq[good], freq[goodbins])</span>
<span class="sd">    &gt;&gt;&gt; freq = np.fft.fftfreq(11)</span>
<span class="sd">    &gt;&gt;&gt; good = freq &gt;= 0</span>
<span class="sd">    &gt;&gt;&gt; goodbins = positive_fft_bins(11, include_zero=True)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(freq[good], freq[goodbins])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The zeroth bin is 0 Hz. We usually don&#39;t include it, but</span>
    <span class="c1"># if the user wants it, we do.</span>
    <span class="n">minbin</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">include_zero</span><span class="p">:</span>
        <span class="n">minbin</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">n_bin</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">minbin</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">minbin</span><span class="p">,</span> <span class="p">(</span><span class="n">n_bin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="poisson_level">
<a class="viewcode-back" href="../../api.html#stingray.fourier.poisson_level">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">poisson_level</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span> <span class="n">meanrate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_ph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backrate</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Poisson (white)-noise level in a periodogram of pure counting noise.</span>

<span class="sd">    For Leahy normalization, this is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = 2</span>

<span class="sd">    For the fractional r.m.s. normalization, this is</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = \frac{2}{\mu}</span>

<span class="sd">    where :math:`\mu` is the average count rate</span>

<span class="sd">    For the absolute r.m.s. normalization, this is</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = 2 \mu</span>

<span class="sd">    Finally, for the unnormalized periodogram, this is</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = N_{\rm ph}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    norm : str, default &quot;frac&quot;</span>
<span class="sd">        Normalization of the periodogram. One of [&quot;abs&quot;, &quot;frac&quot;, &quot;leahy&quot;,</span>
<span class="sd">        &quot;none&quot;].</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    meanrate : float, default None</span>
<span class="sd">        Mean count rate in counts/s. Needed for r.m.s. norms (&quot;abs&quot; and</span>
<span class="sd">        &quot;frac&quot;).</span>
<span class="sd">    n_ph : float, default None</span>
<span class="sd">        Total number of counts in the light curve. Needed if ``norm==&quot;none&quot;``.</span>
<span class="sd">    backrate : float, default 0</span>
<span class="sd">        Background count rate in counts/s. Optional for fractional r.m.s. norm.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the inputs are incompatible with the required normalization.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power_noise : float</span>
<span class="sd">        The Poisson noise level in the wanted normalization.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;leahy&quot;)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;abs&quot;, meanrate=10.)</span>
<span class="sd">    20.0</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;frac&quot;, meanrate=10.)</span>
<span class="sd">    0.2</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;none&quot;, n_ph=10)</span>
<span class="sd">    10.0</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;asdfwrqfasdh3r&quot;, meanrate=10.)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Unknown value for norm: asdfwrqfasdh3r...</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;none&quot;, meanrate=10)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Bad input parameters for norm none...</span>
<span class="sd">    &gt;&gt;&gt; poisson_level(norm=&quot;abs&quot;, n_ph=10)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Bad input parameters for norm abs...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Various ways the parameters are wrong.</span>
    <span class="c1"># We want the noise in rms norm, but don&#39;t specify the mean rate.</span>
    <span class="n">bad_input</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="s2">&quot;frac&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">meanrate</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="c1"># We want the noise in unnormalized powers, without giving n_ph.</span>
    <span class="n">bad_input</span> <span class="o">=</span> <span class="n">bad_input</span> <span class="ow">or</span> <span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span> <span class="ow">and</span> <span class="n">n_ph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bad_input</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Bad input parameters for norm </span><span class="si">{</span><span class="n">norm</span><span class="si">}</span><span class="s2">: n_ph=</span><span class="si">{</span><span class="n">n_ph</span><span class="si">}</span><span class="s2">, &quot;</span> <span class="sa">f</span><span class="s2">&quot;meanrate=</span><span class="si">{</span><span class="n">meanrate</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">meanrate</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;frac&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">meanrate</span> <span class="o">-</span> <span class="n">backrate</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">meanrate</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">2.0</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_ph</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown value for norm: </span><span class="si">{</span><span class="n">norm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="normalize_frac">
<a class="viewcode-back" href="../../api.html#stingray.fourier.normalize_frac">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_frac</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">,</span> <span class="n">mean_flux</span><span class="p">,</span> <span class="n">background_flux</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fractional rms normalization.</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = \frac{P_{\rm Leahy}}{\mu} = \frac{2T}{N_{\rm ph}^2}P_{\rm unnorm}</span>

<span class="sd">    where :math:`\mu` is the mean count rate, :math:`T` is the length of</span>
<span class="sd">    the observation, and :math:`N_{\rm ph}` the number of photons.</span>
<span class="sd">    Alternative formulas found in the literature substitute :math:`T=N\,dt`,</span>
<span class="sd">    :math:`\mu=N_{\rm ph}/T`, which give equivalent results.</span>

<span class="sd">    If the background can be estimated, one can calculate the source rms</span>
<span class="sd">    normalized periodogram as</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = P_{\rm Leahy} \frac{\mu}{(\mu - \beta)^2}</span>

<span class="sd">    or</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = \frac{2T}{(N_{\rm ph} - \beta T)^2}P_{\rm unnorm}</span>

<span class="sd">    where :math:`\beta` is the background count rate.</span>

<span class="sd">    This is also called the Belloni or Miyamoto normalization.</span>
<span class="sd">    In this normalization, the periodogram is in units of</span>
<span class="sd">    :math:`(rms/mean)^2 Hz^{-1}`, and the squared root of the</span>
<span class="sd">    integrated periodogram will give the fractional rms in the</span>
<span class="sd">    required frequency range.</span>

<span class="sd">    Belloni &amp; Hasinger (1990) A&amp;A 230, 103</span>

<span class="sd">    Miyamoto et al. (1991), ApJ 383, 784</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_power : `np.array` of `float` or `complex`</span>
<span class="sd">        The unnormalized (cross-)spectral powers</span>
<span class="sd">    dt : float</span>
<span class="sd">        The sampling time</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        The number of bins in the light curve</span>
<span class="sd">    mean_flux : float</span>
<span class="sd">        The mean of the light curve used to calculate the periodogram.</span>
<span class="sd">        If the light curve is in counts, it gives the mean counts per</span>
<span class="sd">        bin.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    background_flux : float, default 0</span>
<span class="sd">        The background flux, in the same units as `mean_flux`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power : `np.array` of the same kind and shape as `unnorm_power`</span>
<span class="sd">        The normalized powers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mean = var = 1000000</span>
<span class="sd">    &gt;&gt;&gt; back = 100000</span>
<span class="sd">    &gt;&gt;&gt; n_bin = 1000000</span>
<span class="sd">    &gt;&gt;&gt; dt = 0.2</span>
<span class="sd">    &gt;&gt;&gt; meanrate = mean / dt</span>
<span class="sd">    &gt;&gt;&gt; backrate = back / dt</span>
<span class="sd">    &gt;&gt;&gt; lc = np.random.poisson(mean, n_bin)</span>
<span class="sd">    &gt;&gt;&gt; pds = np.abs(fft(lc))**2</span>
<span class="sd">    &gt;&gt;&gt; pdsnorm = normalize_frac(pds, dt, lc.size, mean)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(</span>
<span class="sd">    ...     pdsnorm[1:n_bin//2].mean(), poisson_level(meanrate=meanrate,norm=&quot;frac&quot;), rtol=0.01)</span>
<span class="sd">    &gt;&gt;&gt; pdsnorm = normalize_frac(pds, dt, lc.size, mean, background_flux=back)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(pdsnorm[1:n_bin//2].mean(),</span>
<span class="sd">    ...                   poisson_level(meanrate=meanrate,norm=&quot;frac&quot;,backrate=backrate),</span>
<span class="sd">    ...                   rtol=0.01)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#     (mean * n_bin) / (mean /dt) = n_bin * dt</span>
    <span class="c1">#     It&#39;s Leahy / meanrate;</span>
    <span class="c1">#     n_ph = mean * n_bin</span>
    <span class="c1">#     meanrate = mean / dt</span>
    <span class="c1">#     norm = 2 / (n_ph * meanrate) = 2 * dt / (mean**2 * n_bin)</span>

    <span class="k">if</span> <span class="n">background_flux</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">unnorm_power</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="p">((</span><span class="n">mean_flux</span> <span class="o">-</span> <span class="n">background_flux</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Note: this corresponds to eq. 3 in Uttley+14</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">unnorm_power</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="p">(</span><span class="n">mean_flux</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">power</span></div>



<div class="viewcode-block" id="normalize_abs">
<a class="viewcode-back" href="../../api.html#stingray.fourier.normalize_abs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_abs</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absolute rms normalization.</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = P_{\rm frac} * \mu^2</span>

<span class="sd">    where :math:`\mu` is the mean count rate, or equivalently</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = \frac{2}{T}P_{\rm unnorm}</span>

<span class="sd">    In this normalization, the periodogram is in units of</span>
<span class="sd">    :math:`rms^2 Hz^{-1}`, and the squared root of the</span>
<span class="sd">    integrated periodogram will give the absolute rms in the</span>
<span class="sd">    required frequency range.</span>

<span class="sd">    e.g. Uttley &amp; McHardy, MNRAS 323, L26</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_power : `np.array` of `float` or `complex`</span>
<span class="sd">        The unnormalized (cross-)spectral powers</span>
<span class="sd">    dt : float</span>
<span class="sd">        The sampling time</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        The number of bins in the light curve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power : `np.array` of the same kind and shape as `unnorm_power`</span>
<span class="sd">        The normalized powers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mean = var = 100000</span>
<span class="sd">    &gt;&gt;&gt; n_bin = 1000000</span>
<span class="sd">    &gt;&gt;&gt; dt = 0.2</span>
<span class="sd">    &gt;&gt;&gt; meanrate = mean / dt</span>
<span class="sd">    &gt;&gt;&gt; lc = np.random.poisson(mean, n_bin)</span>
<span class="sd">    &gt;&gt;&gt; pds = np.abs(fft(lc))**2</span>
<span class="sd">    &gt;&gt;&gt; pdsnorm = normalize_abs(pds, dt, lc.size)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(</span>
<span class="sd">    ...     pdsnorm[1:n_bin//2].mean(), poisson_level(norm=&quot;abs&quot;, meanrate=meanrate), rtol=0.01)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#     It&#39;s frac * meanrate**2; Leahy / meanrate * meanrate**2</span>
    <span class="c1">#     n_ph = mean * n_bin</span>
    <span class="c1">#     meanrate = mean / dt</span>
    <span class="c1">#     norm = 2 / (n_ph * meanrate) * meanrate**2 = 2 * dt / (mean**2 * n_bin) * mean**2 / dt**2</span>

    <span class="k">return</span> <span class="n">unnorm_power</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">n_bin</span> <span class="o">/</span> <span class="n">dt</span></div>



<div class="viewcode-block" id="normalize_leahy_from_variance">
<a class="viewcode-back" href="../../api.html#stingray.fourier.normalize_leahy_from_variance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_leahy_from_variance</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Leahy+83 normalization, from the variance of the lc.</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = \frac{P_{\rm unnorm}}{N &lt;\delta{x}^2&gt;}</span>

<span class="sd">    In this normalization, the periodogram of a single light curve</span>
<span class="sd">    is distributed according to a chi squared distribution with two</span>
<span class="sd">    degrees of freedom.</span>

<span class="sd">    In this version, the normalization is obtained by the variance</span>
<span class="sd">    of the light curve bins, instead of the more usual version with the</span>
<span class="sd">    number of photons. This allows to obtain this normalization also</span>
<span class="sd">    in the case of non-Poisson distributed data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_power : `np.array` of `float` or `complex`</span>
<span class="sd">        The unnormalized (cross-)spectral powers</span>
<span class="sd">    variance : float</span>
<span class="sd">        The mean variance of the light curve bins</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        The number of bins in the light curve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power : `np.array` of the same kind and shape as `unnorm_power`</span>
<span class="sd">        The normalized powers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mean = var = 100000.</span>
<span class="sd">    &gt;&gt;&gt; n_bin = 1000000</span>
<span class="sd">    &gt;&gt;&gt; lc = np.random.poisson(mean, n_bin).astype(float)</span>
<span class="sd">    &gt;&gt;&gt; pds = np.abs(fft(lc))**2</span>
<span class="sd">    &gt;&gt;&gt; pdsnorm = normalize_leahy_from_variance(pds, var, lc.size)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(pdsnorm[0], 2 * np.sum(lc), rtol=0.01)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(pdsnorm[1:n_bin//2].mean(), poisson_level(norm=&quot;leahy&quot;), rtol=0.01)</span>

<span class="sd">    If the variance is zero, it will fail:</span>
<span class="sd">    &gt;&gt;&gt; pdsnorm = normalize_leahy_from_variance(pds, 0., lc.size)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: The variance used to normalize the ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The variance used to normalize the periodogram is 0.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unnorm_power</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">variance</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">)</span></div>



<div class="viewcode-block" id="normalize_leahy_poisson">
<a class="viewcode-back" href="../../api.html#stingray.fourier.normalize_leahy_poisson">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_leahy_poisson</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">n_ph</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Leahy+83 normalization.</span>

<span class="sd">    .. math::</span>

<span class="sd">        P = \frac{2}{N_{\rm ph}} P_{\rm unnorm}</span>

<span class="sd">    In this normalization, the periodogram of a single light curve</span>
<span class="sd">    is distributed according to a chi squared distribution with two</span>
<span class="sd">    degrees of freedom.</span>

<span class="sd">    Leahy et al. 1983, ApJ 266, 160</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_power : `np.array` of `float` or `complex`</span>
<span class="sd">        The unnormalized (cross-)spectral powers</span>
<span class="sd">    variance : float</span>
<span class="sd">        The mean variance of the light curve bins</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        The number of bins in the light curve</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power : `np.array` of the same kind and shape as `unnorm_power`</span>
<span class="sd">        The normalized powers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mean = var = 100000.</span>
<span class="sd">    &gt;&gt;&gt; n_bin = 1000000</span>
<span class="sd">    &gt;&gt;&gt; lc = np.random.poisson(mean, n_bin).astype(float)</span>
<span class="sd">    &gt;&gt;&gt; pds = np.abs(fft(lc))**2</span>
<span class="sd">    &gt;&gt;&gt; pdsnorm = normalize_leahy_poisson(pds, np.sum(lc))</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(pdsnorm[0], 2 * np.sum(lc), rtol=0.01)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(pdsnorm[1:n_bin//2].mean(), poisson_level(norm=&quot;leahy&quot;), rtol=0.01)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">unnorm_power</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">n_ph</span></div>



<div class="viewcode-block" id="normalize_periodograms">
<a class="viewcode-back" href="../../api.html#stingray.fourier.normalize_periodograms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_periodograms</span><span class="p">(</span>
    <span class="n">unnorm_power</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">,</span>
    <span class="n">n_bin</span><span class="p">,</span>
    <span class="n">mean_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_ph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">background_flux</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span>
    <span class="n">power_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around all the normalize_NORM methods.</span>

<span class="sd">    Normalize the cross-spectrum or the power-spectrum to Leahy, absolute rms^2,</span>
<span class="sd">    fractional rms^2 normalization, or not at all.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_power: numpy.ndarray</span>
<span class="sd">        The unnormalized cross spectrum.</span>

<span class="sd">    dt: float</span>
<span class="sd">        The sampling time of the light curve</span>

<span class="sd">    n_bin: int</span>
<span class="sd">        The number of bins in the light curve</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    mean_flux: float</span>
<span class="sd">        The mean of the light curve used to calculate the powers</span>
<span class="sd">        (If a cross spectrum, the geometrical mean of the light</span>
<span class="sd">        curves in the two channels). Only relevant for &quot;frac&quot; normalization</span>

<span class="sd">    n_ph: int or float</span>
<span class="sd">        The number of counts in the light curve used to calculate</span>
<span class="sd">        the unnormalized periodogram. Only relevant for Leahy normalization.</span>

<span class="sd">    variance: float</span>
<span class="sd">        The average variance of the measurements in light curve (if a cross</span>
<span class="sd">        spectrum,  the geometrical mean of the variances in the two channels).</span>
<span class="sd">        **NOT** the variance of the light curve, but of each flux measurement</span>
<span class="sd">        (square of light curve error bar)! Only relevant for the Leahy</span>
<span class="sd">        normalization of non-Poissonian data.</span>

<span class="sd">    norm : str</span>
<span class="sd">        One of ``leahy`` (Leahy+83), ``frac`` (fractional rms), ``abs``</span>
<span class="sd">        (absolute rms),</span>

<span class="sd">    power_type : str</span>
<span class="sd">        One of ``real`` (real part), ``all`` (all complex powers), ``abs``</span>
<span class="sd">        (absolute value)</span>

<span class="sd">    background_flux : float, default 0</span>
<span class="sd">        The background flux, in the same units as `mean_flux`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power: numpy.nd.array</span>
<span class="sd">        The normalized co-spectrum (real part of the cross spectrum). For</span>
<span class="sd">        &#39;none&#39; normalization, imaginary part is returned as well.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span> <span class="ow">and</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="n">normalize_leahy_from_variance</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span><span class="p">:</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="n">normalize_leahy_poisson</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">n_ph</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;frac&quot;</span><span class="p">:</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="n">normalize_frac</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">,</span> <span class="n">mean_flux</span><span class="p">,</span> <span class="n">background_flux</span><span class="o">=</span><span class="n">background_flux</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="n">normalize_abs</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="n">unnorm_power</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for the norm&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">power_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pds</span>
    <span class="k">if</span> <span class="n">power_type</span> <span class="o">==</span> <span class="s2">&quot;real&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pds</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">power_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="s2">&quot;absolute&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pds</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized power type&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="unnormalize_periodograms">
<a class="viewcode-back" href="../../api.html#stingray.fourier.unnormalize_periodograms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unnormalize_periodograms</span><span class="p">(</span>
    <span class="n">norm_power</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">,</span> <span class="n">n_ph</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">background_flux</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">power_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around all the normalize_NORM methods.</span>

<span class="sd">    Unnormalize the power of the cross-spectrum to Leahy, absolute rms^2,</span>
<span class="sd">    fractional rms^2 normalization, or not at all.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    norm_power: numpy.ndarray</span>
<span class="sd">        The normalized cross-spectrum or poisson noise</span>

<span class="sd">    dt: float</span>
<span class="sd">        The sampling time of the light curve</span>

<span class="sd">    n_bin: int</span>
<span class="sd">        The number of bins in the light curve</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    mean_flux: float</span>
<span class="sd">        The mean of the light curve used to calculate the powers</span>
<span class="sd">        (If a cross spectrum, the geometrical mean of the light</span>
<span class="sd">        curves in the two channels). Only relevant for &quot;frac&quot; normalization</span>

<span class="sd">    n_ph: int or float</span>
<span class="sd">        The number of counts in the light curve used to calculate</span>
<span class="sd">        the unnormalized periodogram. Only relevant for Leahy normalization.</span>

<span class="sd">    variance: float</span>
<span class="sd">        The average variance of the measurements in light curve (if a cross</span>
<span class="sd">        spectrum,  the geometrical mean of the variances in the two channels).</span>
<span class="sd">        **NOT** the variance of the light curve, but of each flux measurement</span>
<span class="sd">        (square of light curve error bar)! Only relevant for the Leahy</span>
<span class="sd">        normalization of non-Poissonian data.</span>

<span class="sd">    norm : str</span>
<span class="sd">        One of ``leahy`` (Leahy+83), ``frac`` (fractional rms), ``abs``</span>
<span class="sd">        (absolute rms),</span>

<span class="sd">    power_type : str</span>
<span class="sd">        One of ``real`` (real part), ``all`` (all complex powers), ``abs``</span>
<span class="sd">        (absolute value)</span>

<span class="sd">    background_flux : float, default 0</span>
<span class="sd">        The background flux, in the same units as `mean_flux`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    power: numpy.nd.array</span>
<span class="sd">        The normalized co-spectrum (real part of the cross spectrum). For</span>
<span class="sd">        &#39;none&#39; normalization, imaginary part is returned as well.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span> <span class="ow">and</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">norm_power</span> <span class="o">*</span> <span class="p">(</span><span class="n">variance</span> <span class="o">*</span> <span class="n">n_ph</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;leahy&quot;</span><span class="p">:</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">norm_power</span> <span class="o">*</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;frac&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">background_flux</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">norm_power</span> <span class="o">*</span> <span class="p">((</span><span class="n">n_ph</span> <span class="o">/</span> <span class="n">n_bin</span> <span class="o">-</span> <span class="n">background_flux</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">norm_power</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_ph</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">n_bin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">norm_power</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">norm_power</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for the norm&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">power_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unnorm_power</span>
    <span class="k">if</span> <span class="n">power_type</span> <span class="o">==</span> <span class="s2">&quot;real&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unnorm_power</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">power_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="s2">&quot;absolute&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized power type&quot;</span><span class="p">)</span></div>



<span class="nd">@vectorize</span><span class="p">([</span><span class="n">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">float64</span><span class="p">)],</span> <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_bias_term</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">input_intrinsic_coherence</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n_ave</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="n">bsq</span> <span class="o">=</span> <span class="n">power1</span> <span class="o">*</span> <span class="n">power2</span> <span class="o">-</span> <span class="n">input_intrinsic_coherence</span> <span class="o">*</span> <span class="p">(</span><span class="n">power1</span> <span class="o">-</span> <span class="n">power1_noise</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">power2</span> <span class="o">-</span> <span class="n">power2_noise</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">bsq</span> <span class="o">/</span> <span class="n">n_ave</span>


<div class="viewcode-block" id="bias_term">
<a class="viewcode-back" href="../../api.html#stingray.fourier.bias_term">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bias_term</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">intrinsic_coherence</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bias term needed to calculate the coherence.</span>

<span class="sd">    Introduced by</span>
<span class="sd">    Vaughan &amp; Nowak 1997, ApJ 474, L43</span>

<span class="sd">    but implemented here according to the formulation in</span>
<span class="sd">    Ingram 2019, MNRAS 489, 392</span>

<span class="sd">    As recommended in the latter paper, returns 0 if n_ave &gt; 500</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    intrinsic_coherence : float, default 1</span>
<span class="sd">        If known, the intrinsic coherence.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bias : float `np.array`, same shape as ``power1`` and ``power2``</span>
<span class="sd">        The bias term</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_bias_term</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">intrinsic_coherence</span><span class="p">)</span></div>



<span class="nd">@vectorize</span><span class="p">([</span><span class="n">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">)],</span> <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_apply_low_lim_to_coherence_uncertainty</span><span class="p">(</span><span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span><span class="p">,</span> <span class="n">min_uncertainty</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a low limit to the uncertainty on the coherence, to avoid zero or negative uncertainties.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coherence : float or float `np.array`</span>
<span class="sd">        The coherence values at all frequencies.</span>
<span class="sd">    uncertainty : float or float `np.array`</span>
<span class="sd">        The uncertainty on the coherence at all frequencies. Must have the same</span>
<span class="sd">        shape as `coherence`.</span>
<span class="sd">    min_uncertainty : float or float `np.array`</span>
<span class="sd">        The minimum uncertainty to apply. Can be a single value or an array of</span>
<span class="sd">        the same shape as `coherence` and `uncertainty`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    uncertainty : float or float `np.array`</span>
<span class="sd">        The uncertainty on the coherence, with the low limit applied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; coherence = np.array([0.5, 0.0, 0.5])</span>
<span class="sd">    &gt;&gt;&gt; uncertainty = np.array([0.1, 0.0, 0.05])</span>
<span class="sd">    &gt;&gt;&gt; min_uncertainty = 0.01</span>
<span class="sd">    &gt;&gt;&gt; expected = np.array([0.1, 0.01, 0.05])</span>
<span class="sd">    &gt;&gt;&gt; res = _apply_low_lim_to_coherence_uncertainty(coherence, uncertainty, min_uncertainty)</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(res, expected)</span>

<span class="sd">    # The same, but with a different minimum uncertainty for each frequency.</span>
<span class="sd">    &gt;&gt;&gt; min_uncertainty = np.array([0.01, 0.1, 0.1])</span>
<span class="sd">    &gt;&gt;&gt; res = _apply_low_lim_to_coherence_uncertainty(coherence, uncertainty, min_uncertainty)</span>
<span class="sd">    &gt;&gt;&gt; expected = np.array([0.1, 0.1, 0.1])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(res, expected)</span>

<span class="sd">    # All the same, but with scalar inputs.</span>
<span class="sd">    &gt;&gt;&gt; coherence = 0.5</span>
<span class="sd">    &gt;&gt;&gt; uncertainty = 0.0</span>
<span class="sd">    &gt;&gt;&gt; min_uncertainty = 0.01</span>
<span class="sd">    &gt;&gt;&gt; expected = 0.01</span>
<span class="sd">    &gt;&gt;&gt; res = _apply_low_lim_to_coherence_uncertainty(coherence, uncertainty, min_uncertainty)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isclose(res, expected)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">coherence</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">uncertainty</span> <span class="o">&lt;</span> <span class="n">min_uncertainty</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bad</span><span class="p">:</span>
        <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">min_uncertainty</span>
    <span class="k">return</span> <span class="n">uncertainty</span>


<span class="nd">@vectorize</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="s2">&quot;UniTuple(float64[:, :], 2)(float64[:, :], float64[:, :], float64[:, :], float64, float64, int64, float64)&quot;</span>
    <span class="p">],</span>
    <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_raw_coherence</span><span class="p">(</span>
    <span class="n">cross_power</span><span class="p">,</span>
    <span class="n">power1</span><span class="p">,</span>
    <span class="n">power2</span><span class="p">,</span>
    <span class="n">power1_noise</span><span class="p">,</span>
    <span class="n">power2_noise</span><span class="p">,</span>
    <span class="n">n_ave</span><span class="p">,</span>
    <span class="n">intrinsic_coherence</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raw coherence estimations from cross and power spectra.</span>

<span class="sd">    Vaughan &amp; Nowak 1997, ApJ 474, L43</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    intrinsic_coherence : float, default 1</span>
<span class="sd">        If known, the intrinsic coherence.</span>
<span class="sd">    return_uncertainty : bool, default False</span>
<span class="sd">        Whether to return the uncertainty on the coherence, calculated according to VN97</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coherence : float `np.array`</span>
<span class="sd">        The raw coherence values at all frequencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bsq</span> <span class="o">=</span> <span class="n">bias_term</span><span class="p">(</span>
        <span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">intrinsic_coherence</span><span class="o">=</span><span class="n">intrinsic_coherence</span>
    <span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">cross_power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">cross_power</span><span class="p">))</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">bsq</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">power1</span> <span class="o">*</span> <span class="n">power2</span>

    <span class="n">coherence</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
    <span class="n">min_uncertainty</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="n">uncertainty</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">coherence</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">coherence</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coherence</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_ave</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">_apply_low_lim_to_coherence_uncertainty</span><span class="p">(</span><span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span><span class="p">,</span> <span class="n">min_uncertainty</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span>


<div class="viewcode-block" id="raw_coherence">
<a class="viewcode-back" href="../../api.html#stingray.fourier.raw_coherence">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">raw_coherence</span><span class="p">(</span>
    <span class="n">cross_power</span><span class="p">,</span>
    <span class="n">power1</span><span class="p">,</span>
    <span class="n">power2</span><span class="p">,</span>
    <span class="n">power1_noise</span><span class="p">,</span>
    <span class="n">power2_noise</span><span class="p">,</span>
    <span class="n">n_ave</span><span class="p">,</span>
    <span class="n">intrinsic_coherence</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raw coherence estimations from cross and power spectra.</span>

<span class="sd">    The function is defined as (see Ingram 2019 [#]_ :</span>

<span class="sd">    .. math::</span>

<span class="sd">        \tilde{g}^2(f) = \frac{|\langle \tilde{C}(f) \rangle|^2 - \tilde{b}^2}</span>
<span class="sd">        {\langle \tilde{P}_1(f) \rangle \langle \tilde{P}_2(f) \rangle}</span>

<span class="sd">    where :math:`\tilde{b}^2` is the bias term that accounts for the contribution of Poisson</span>
<span class="sd">    noise to the cross spectrum (see :func:`stingray.fourier.bias_term`), and tilde generally indicates noisy</span>
<span class="sd">    measurements of the cross spectrum :math:`C` and the power spectra :math:`P_n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    intrinsic_coherence : float, default 1</span>
<span class="sd">        If known, the intrinsic coherence.</span>
<span class="sd">    return_uncertainty : bool, default False</span>
<span class="sd">        Whether to return the uncertainty on the coherence, calculated according to VN97</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coherence : float `np.array`</span>
<span class="sd">        The raw coherence values at all frequencies.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [#] https://doi.org/10.1093/mnras/stz2409</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">_raw_coherence</span><span class="p">(</span>
        <span class="n">cross_power</span><span class="p">,</span>
        <span class="n">power1</span><span class="p">,</span>
        <span class="n">power2</span><span class="p">,</span>
        <span class="n">power1_noise</span><span class="p">,</span>
        <span class="n">power2_noise</span><span class="p">,</span>
        <span class="n">n_ave</span><span class="p">,</span>
        <span class="n">intrinsic_coherence</span><span class="o">=</span><span class="n">intrinsic_coherence</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_uncertainty</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span>
    <span class="k">return</span> <span class="n">coherence</span></div>



<span class="nd">@njit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_intrinsic_coherence_uncertainties</span><span class="p">(</span>
    <span class="n">bsq</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">power1_sub</span><span class="p">,</span> <span class="n">power2_sub</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">n_ave</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the uncertainty on the intrinsic coherence, according to VN97, eq. 8.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bsq : float</span>
<span class="sd">        The bias term squared, calculated according to the bias_term function.</span>
<span class="sd">    num : float</span>
<span class="sd">        The numerator of the coherence calculation, i.e. (cross_power * np.conj(cross_power)).real - bsq.</span>
<span class="sd">    power1_sub : float</span>
<span class="sd">        The subtracted power of the first band, i.e. power1 - power1_noise</span>
<span class="sd">    power2_sub : float</span>
<span class="sd">        The subtracted power of the second band, i.e. power2 - power2_noise</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        The Poisson noise level of the first band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        The Poisson noise level of the second band periodogram</span>
<span class="sd">    coherence : float</span>
<span class="sd">        The intrinsic coherence calculated according to the _intrinsic_coherence function.</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        The number of intervals that have been averaged to obtain the input spectra</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Terms from VN97, eq. 8, for the uncertainty on the coherence.</span>
    <span class="n">err1</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">bsq</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_ave</span> <span class="o">/</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">bsq</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">err2</span> <span class="o">=</span> <span class="p">(</span><span class="n">power1_noise</span> <span class="o">/</span> <span class="n">power1_sub</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">power2_noise</span> <span class="o">/</span> <span class="n">power2_sub</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">err3</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">coherence</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">coherence</span><span class="o">**</span><span class="mf">1.5</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">coherence</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_ave</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err1</span> <span class="o">+</span> <span class="n">err2</span> <span class="o">+</span> <span class="n">err3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uncertainty</span>


<span class="nd">@vectorize</span><span class="p">(</span>
    <span class="p">[</span><span class="s2">&quot;UniTuple(float64[:, :], 2)(float64[:, :], float64[:, :], float64, float64, int64)&quot;</span><span class="p">],</span>
    <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">check_powers_for_intrinsic_coherence</span><span class="p">(</span>
    <span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">3</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the powers are above the threshold for the intrinsic coherence to be well defined.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    threshold : float, default 3</span>
<span class="sd">        The threshold in sigma above the noise level for the powers to be considered &quot;high&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    low_power1 : bool `np.array`</span>
<span class="sd">        Whether the powers of the first band are below the threshold.</span>
<span class="sd">    low_power2 : bool `np.array`</span>
<span class="sd">        Whether the powers of the second band are below the threshold.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Consider low power when the power is less than 3 sigma above the noise level.</span>
    <span class="c1"># This is somewhat arbitrary, better criteria suggestions are welcome.</span>
    <span class="n">low_power1</span> <span class="o">=</span> <span class="p">(</span><span class="n">power1</span> <span class="o">-</span> <span class="n">power1_noise</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">power1_noise</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_ave</span><span class="p">)</span>
    <span class="n">low_power2</span> <span class="o">=</span> <span class="p">(</span><span class="n">power2</span> <span class="o">-</span> <span class="n">power2_noise</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">power2_noise</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_ave</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">low_power1</span> <span class="ow">or</span> <span class="n">low_power2</span>


<span class="nd">@vectorize</span><span class="p">(</span>
    <span class="p">[</span><span class="s2">&quot;UniTuple(float64[:, :], 2)(float64, float64, float64, float64, float64, int64, float64)&quot;</span><span class="p">],</span>
    <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_intrinsic_coherence</span><span class="p">(</span>
    <span class="n">cross_power</span><span class="p">,</span>
    <span class="n">power1</span><span class="p">,</span>
    <span class="n">power2</span><span class="p">,</span>
    <span class="n">power1_noise</span><span class="p">,</span>
    <span class="n">power2_noise</span><span class="p">,</span>
    <span class="n">n_ave</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intrinsic coherence estimations from cross and power spectra.</span>

<span class="sd">    Vaughan &amp; Nowak 1997, ApJ 474, L43</span>

<span class="sd">    For errors, assumes **high powers, high coherence**. See eq. 8 of the paper.</span>
<span class="sd">    Powers below 3 sigma above the noise level (P_noise / sqrt(MW)) are considered too low,</span>
<span class="sd">    and the coherence will be set to NaN.</span>

<span class="sd">    TODO: implement a more general treatment of the uncertainty.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    return_uncertainty : bool, default False</span>
<span class="sd">        Whether to return the uncertainty on the coherence, calculated according to</span>
<span class="sd">        Vaughan &amp; Nowak 1997, ApJ 474, L43, eq. 8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coherence : float `np.array` or tuple of two float `np.array`</span>
<span class="sd">        The intrinsic coherence values at all frequencies. It is 0 if the numerator</span>
<span class="sd">        of the coherence calculation is negative, and NaN if the powers are too low compared</span>
<span class="sd">        to the noise level.</span>
<span class="sd">    uncertainty : float `np.array`, optional</span>
<span class="sd">        The uncertainty on the intrinsic coherence, calculated according to Vaughan &amp; Nowak</span>
<span class="sd">        1997, ApJ 474, L43, eq. 8.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">check_powers_for_intrinsic_coherence</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">):</span>
        <span class="c1"># If the powers are too close to the noise level, the coherence is not well defined.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">bsq</span> <span class="o">=</span> <span class="n">_bias_term</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">cross_power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">cross_power</span><span class="p">))</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">bsq</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">power1_sub</span> <span class="o">=</span> <span class="n">power1</span> <span class="o">-</span> <span class="n">power1_noise</span>
    <span class="n">power2_sub</span> <span class="o">=</span> <span class="n">power2</span> <span class="o">-</span> <span class="n">power2_noise</span>

    <span class="n">den</span> <span class="o">=</span> <span class="n">power1_sub</span> <span class="o">*</span> <span class="n">power2_sub</span>

    <span class="n">coherence</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>

    <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">_intrinsic_coherence_uncertainties</span><span class="p">(</span>
        <span class="n">bsq</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">power1_sub</span><span class="p">,</span> <span class="n">power2_sub</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">n_ave</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span>


<span class="nd">@vectorize</span><span class="p">(</span>
    <span class="p">[</span><span class="s2">&quot;UniTuple(float64[:, :], 2)(float64, float64, float64, float64, float64, int64)&quot;</span><span class="p">],</span>
    <span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_intrinsic_coherence_with_adjusted_bias</span><span class="p">(</span>
    <span class="n">cross_power</span><span class="p">,</span>
    <span class="n">power1</span><span class="p">,</span>
    <span class="n">power2</span><span class="p">,</span>
    <span class="n">power1_noise</span><span class="p">,</span>
    <span class="n">power2_noise</span><span class="p">,</span>
    <span class="n">n_ave</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intrinsic coherence estimations from cross and power spectra, with adjusted bias term.</span>

<span class="sd">    Follows the procedure from sec. 5 of Ingram 2019, MNRAS 489, 3927, which iteratively</span>
<span class="sd">    adjusts the bias term</span>

<span class="sd">    For errors, assumes **high powers, high coherence**. See eq. 8 of Vaughan &amp; Nowak 1997.</span>
<span class="sd">    Powers below 3 sigma above the noise level (P_noise / sqrt(MW)) are considered too low,</span>
<span class="sd">    and the coherence will be set to NaN.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    atol: float, default 0.01</span>
<span class="sd">        The absolute tolerance for the convergence of the iterative procedure to adjust</span>
<span class="sd">        the bias term.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coherence : float `np.array` or tuple of two float `np.array`</span>
<span class="sd">        The intrinsic coherence values at all frequencies. It is 0 if the numerator</span>
<span class="sd">        of the coherence calculation is negative, and NaN if the powers are too low compared</span>
<span class="sd">        to the noise level.</span>
<span class="sd">    uncertainty : float `np.array`, optional</span>
<span class="sd">        The uncertainty on the intrinsic coherence, calculated according to Vaughan &amp; Nowak</span>
<span class="sd">        1997, ApJ 474, L43, eq. 8.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">check_powers_for_intrinsic_coherence</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">):</span>
        <span class="c1"># If the powers are too close to the noise level, the coherence is not well defined.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Consider low power when the power is less than 3 sigma above the noise level.</span>
    <span class="c1"># This is somewhat arbitrary, better criteria suggestions are welcome.</span>
    <span class="n">power1_sub</span> <span class="o">=</span> <span class="n">power1</span> <span class="o">-</span> <span class="n">power1_noise</span>
    <span class="n">power2_sub</span> <span class="o">=</span> <span class="n">power2</span> <span class="o">-</span> <span class="n">power2_noise</span>

    <span class="n">current_coherence</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">40</span><span class="p">):</span>
        <span class="n">bsq</span> <span class="o">=</span> <span class="n">_bias_term</span><span class="p">(</span><span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">current_coherence</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">cross_power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">cross_power</span><span class="p">))</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">bsq</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coherence</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># if the current coherence still drops, the bias term increases,</span>
            <span class="c1"># so at this point it is useless to keep iterating.</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">den</span> <span class="o">=</span> <span class="n">power1_sub</span> <span class="o">*</span> <span class="n">power2_sub</span>

        <span class="n">coherence</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">current_coherence</span> <span class="o">-</span> <span class="n">coherence</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">current_coherence</span> <span class="o">=</span> <span class="n">coherence</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The iterative procedure to adjust the bias term did not converge after 40 iterations. &quot;</span>
            <span class="s2">&quot;Consider rebinning the spectra to increase the signal-to-noise ratio, or to use a &quot;</span>
            <span class="s2">&quot;more permissive tolerance (``atol`` parameter).&quot;</span>
        <span class="p">)</span>

    <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">_intrinsic_coherence_uncertainties</span><span class="p">(</span>
        <span class="n">bsq</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">power1_sub</span><span class="p">,</span> <span class="n">power2_sub</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">n_ave</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span>


<div class="viewcode-block" id="intrinsic_coherence">
<a class="viewcode-back" href="../../api.html#stingray.fourier.intrinsic_coherence">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">intrinsic_coherence</span><span class="p">(</span>
    <span class="n">cross_power</span><span class="p">,</span>
    <span class="n">power1</span><span class="p">,</span>
    <span class="n">power2</span><span class="p">,</span>
    <span class="n">power1_noise</span><span class="p">,</span>
    <span class="n">power2_noise</span><span class="p">,</span>
    <span class="n">n_ave</span><span class="p">,</span>
    <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">adjust_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intrinsic coherence estimations from cross and power spectra.</span>

<span class="sd">    Vaughan &amp; Nowak 1997, ApJ 474, L43</span>

<span class="sd">    .. math::</span>

<span class="sd">        \tilde{\gamma}^2(f) = \frac{|\langle \tilde{C}(f) \rangle|^2 - \tilde{b}^2}</span>
<span class="sd">        {(\langle \tilde{P}_1(f) \rangle - \tilde{P}_{1, \rm noise})</span>
<span class="sd">        (\langle \tilde{P}_2(f) \rangle - \tilde{P}_{2, \rm noise})}</span>

<span class="sd">    where :math:`\tilde{b}^2` is the bias term that accounts for the contribution of Poisson</span>
<span class="sd">    noise to the cross spectrum (see :func:`stingray.fourier.bias_term`), and tilde generally</span>
<span class="sd">    indicates noisy measurements of the cross spectrum :math:`C` and the power spectra :math:`P_n`.</span>
<span class="sd">    The terms :math:`\tilde{P}_{\rm n, \rm noise}` are the estimates of the contribution of</span>
<span class="sd">    Poisson noise to the power spectra.</span>

<span class="sd">    The bias term depends on the intrinsic coherence itself, so it can be calculated iteratively</span>
<span class="sd">    following the procedure from sec. 5 of Ingram 2019, MNRAS 489, 3927, which adjusts the bias</span>
<span class="sd">    term until convergence is reached. This is done if ``adjust_bias`` is set to True. It is</span>
<span class="sd">    typically a very small correction.</span>

<span class="sd">    For errors, assumes **high powers, high coherence**. See eq. 8 of the paper.</span>
<span class="sd">    Powers below 3 sigma above the noise level (P_noise / sqrt(MW)) are considered too low,</span>
<span class="sd">    and the coherence will be set to NaN.</span>

<span class="sd">    TODO: implement a more general treatment of the uncertainty.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    return_uncertainty : bool, default False</span>
<span class="sd">        Whether to return the uncertainty on the coherence, calculated according to</span>
<span class="sd">        Vaughan &amp; Nowak 1997, ApJ 474, L43, eq. 8.</span>
<span class="sd">    atol: float, default 0.01</span>
<span class="sd">        The absolute tolerance for the convergence of the iterative procedure to adjust</span>
<span class="sd">        the bias term.Only relevant if ``adjust_bias`` is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coherence : float `np.array` or tuple of two float `np.array`</span>
<span class="sd">        The intrinsic coherence values at all frequencies. It is 0 if the numerator</span>
<span class="sd">        of the coherence calculation is negative, and NaN if the powers are too low compared</span>
<span class="sd">        to the noise level.</span>
<span class="sd">    uncertainty : float `np.array`, optional</span>
<span class="sd">        The uncertainty on the intrinsic coherence, calculated according to Vaughan &amp; Nowak</span>
<span class="sd">        1997, ApJ 474, L43, eq. 8.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">adjust_bias</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_intrinsic_coherence_with_adjusted_bias</span><span class="p">(</span>
            <span class="n">cross_power</span><span class="p">,</span> <span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_intrinsic_coherence</span><span class="p">(</span>
            <span class="n">cross_power</span><span class="p">,</span> <span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span>
        <span class="p">)</span>
    <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">result</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coherence</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;NaN values detected in intrinsic_coherence calculation. This happens when the powers &quot;</span>
            <span class="s2">&quot;are too close to the noise level, and the coherence is not well defined. Consider &quot;</span>
            <span class="s2">&quot;rebinning the spectra to increase the signal-to-noise ratio.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">coherence</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Zero values detected in intrinsic_coherence calculation. This usually happens&quot;</span>
            <span class="s2">&quot; when the bias term is larger than the cross spectrum, and the coherence is not&quot;</span>
            <span class="s2">&quot; well defined. &quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_uncertainty</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">uncertainty</span>
    <span class="k">return</span> <span class="n">coherence</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">estimate_intrinsic_coherence</span><span class="p">(</span><span class="n">cross_power</span><span class="p">,</span> <span class="n">power1</span><span class="p">,</span> <span class="n">power2</span><span class="p">,</span> <span class="n">power1_noise</span><span class="p">,</span> <span class="n">power2_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate intrinsic coherence</span>

<span class="sd">    Use the iterative procedure from sec. 5 of</span>

<span class="sd">    Ingram 2019, MNRAS 489, 392</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    power1 : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    power2 : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    power1_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    power2_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coherence : float `np.array`</span>
<span class="sd">        The estimated intrinsic coherence, at all frequencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;estimate_intrinsic_coherence is deprecated. Use intrinsic_coherence with adjust_bias=True instead.&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">new_coherence</span> <span class="o">=</span> <span class="n">intrinsic_coherence</span><span class="p">(</span>
        <span class="n">cross_power</span><span class="p">,</span>
        <span class="n">power1</span><span class="p">,</span>
        <span class="n">power2</span><span class="p">,</span>
        <span class="n">power1_noise</span><span class="p">,</span>
        <span class="n">power2_noise</span><span class="p">,</span>
        <span class="n">n_ave</span><span class="p">,</span>
        <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">adjust_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">new_coherence</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_rms_from_rms_norm_periodogram</span><span class="p">(</span><span class="n">power_sqrms</span><span class="p">,</span> <span class="n">poisson_noise_sqrms</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">low_M_buffer_size</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate integrated rms spectrum (frac or abs).</span>

<span class="sd">    If M=1, it starts by rebinning the powers slightly in order to get a slightly</span>
<span class="sd">    better approximation for the error bars.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    power_sqrms: array-like</span>
<span class="sd">        Powers, in units of fractional rms ($(rms/mean)^2 Hz{-1}$)</span>
<span class="sd">    poisson_noise_sqrms: float</span>
<span class="sd">        Poisson noise level, in units of fractional rms ($(rms/mean)^2 Hz{-1}$</span>
<span class="sd">    df: float or ``np.array``, same dimension of ``power_sqrms``</span>
<span class="sd">        The frequency resolution of each power</span>
<span class="sd">    M: int or ``np.array``, same dimension of ``power_sqrms``</span>
<span class="sd">        The number of powers averaged to obtain each value of power.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    low_M_buffer_size : int, default 4</span>
<span class="sd">        If M=1, the powers are rebinned to have a minimum of ``low_M_buffer_size`` powers</span>
<span class="sd">        in each bin. This is done to get a better estimate of the error bars.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">stingray.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">rebin_data</span>

    <span class="n">m_is_iterable</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
    <span class="n">df_is_iterable</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>

    <span class="c1"># if M is an iterable but all values are the same, let&#39;s simplify</span>
    <span class="k">if</span> <span class="n">m_is_iterable</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">M</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m_is_iterable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># the same with df</span>
    <span class="k">if</span> <span class="n">df_is_iterable</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">df_is_iterable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">low_M_values</span> <span class="o">=</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">30</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">M</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">):</span>
        <span class="n">quantity</span> <span class="o">=</span> <span class="s2">&quot;Some&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m_is_iterable</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">low_M_values</span><span class="p">)</span> <span class="o">==</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">quantity</span> <span class="o">=</span> <span class="s2">&quot;All&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">quantity</span><span class="si">}</span><span class="s2"> power spectral bins have M&lt;30. The error bars on the rms might be wrong. &quot;</span>
            <span class="s2">&quot;In some cases one might try to increase the number of segments, for example by &quot;</span>
            <span class="s2">&quot;reducing the segment size, in order to obtain at least 30 segments.&quot;</span>
        <span class="p">)</span>
    <span class="c1"># But they cannot be of different kind. There would be something wrong with the data</span>
    <span class="k">if</span> <span class="n">m_is_iterable</span> <span class="o">!=</span> <span class="n">df_is_iterable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M and df must be either both constant, or none of them.&quot;</span><span class="p">)</span>

    <span class="c1"># If powers are not rebinned and M=1, we rebin them slightly. The error on the power is tricky,</span>
    <span class="c1"># because powers follow a non-central chi squared distribution. If we combine powers with</span>
    <span class="c1"># very different underlying signal level, the error bars will be completely wrong. But</span>
    <span class="c1"># nearby powers have a higher chance of having similar values, and so, by combining them,</span>
    <span class="c1"># we have a higher chance of obtaining sensible quasi-Gaussian error bars, easier to</span>
    <span class="c1"># propagate through standard quadrature summation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m_is_iterable</span> <span class="ow">and</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">power_sqrms</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">low_M_buffer_size</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">local_power_sqrms</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">local_M</span> <span class="o">=</span> <span class="n">rebin_data</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">power_sqrms</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="p">,</span>
            <span class="n">power_sqrms</span><span class="p">,</span>
            <span class="n">df</span> <span class="o">*</span> <span class="n">low_M_buffer_size</span><span class="p">,</span>
            <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">local_df</span> <span class="o">=</span> <span class="n">df</span> <span class="o">*</span> <span class="n">local_M</span>
        <span class="n">total_local_powers</span> <span class="o">=</span> <span class="n">local_M</span> <span class="o">*</span> <span class="n">local_power_sqrms</span><span class="o">.</span><span class="n">size</span>
        <span class="n">total_power_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">local_power_sqrms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">local_df</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">local_M</span><span class="p">))</span>
        <span class="n">total_power_err</span> <span class="o">*=</span> <span class="n">power_sqrms</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">total_local_powers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_power_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">power_sqrms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">df</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">M</span><span class="p">))</span>

    <span class="n">powers_sub</span> <span class="o">=</span> <span class="n">power_sqrms</span> <span class="o">-</span> <span class="n">poisson_noise_sqrms</span>

    <span class="n">total_power_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">powers_sub</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">total_power_sub</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># By the definition, it makes no sense to define an error bar here.</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Poisson-subtracted power is below 0&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

    <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">total_power_sub</span><span class="p">)</span>

    <span class="n">high_snr_err</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">rms</span> <span class="o">*</span> <span class="n">total_power_err</span>

    <span class="k">return</span> <span class="n">rms</span><span class="p">,</span> <span class="n">high_snr_err</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_rms_from_unnorm_periodogram</span><span class="p">(</span>
    <span class="n">unnorm_powers</span><span class="p">,</span>
    <span class="n">nphots_per_segment</span><span class="p">,</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">poisson_noise_unnorm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">segment_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the fractional rms amplitude from unnormalized powers.</span>

<span class="sd">    We assume the powers come from an unnormalized Bartlett periodogram.</span>
<span class="sd">    If so, the Poisson noise level is ``nphots_per_segment``, but the user</span>
<span class="sd">    can specify otherwise (e.g. if the Poisson noise level is altered by dead time).</span>
<span class="sd">    The ``segment_size`` and ``nphots_per_segment`` parameters refer to the length</span>
<span class="sd">    and averaged counts of each segment of data used for the Bartlett periodogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_powers : np.ndarray</span>
<span class="sd">        The unnormalized power spectrum</span>
<span class="sd">    nphots_per_segment : float</span>
<span class="sd">        The averaged number of photons per segment of the data used for the Bartlett periodogram</span>
<span class="sd">    df : float</span>
<span class="sd">        The frequency resolution of the periodogram</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    poisson_noise_unnorm : float</span>
<span class="sd">        The unnormalized Poisson noise level</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        The size of the segment, in seconds</span>
<span class="sd">    M : int</span>
<span class="sd">        The number of segments averaged to obtain the periodogram</span>
<span class="sd">    kind : str</span>
<span class="sd">        One of &quot;frac&quot; or &quot;abs&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segment_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">poisson_noise_unnorm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">poisson_noise_unnorm</span> <span class="o">=</span> <span class="n">nphots_per_segment</span>

    <span class="n">meanrate</span> <span class="o">=</span> <span class="n">nphots_per_segment</span> <span class="o">/</span> <span class="n">segment_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_leahy</span><span class="p">(</span><span class="n">powers</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">powers</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">nphots_per_segment</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_frac</span><span class="p">(</span><span class="n">powers</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_leahy</span><span class="p">(</span><span class="n">powers</span><span class="p">)</span> <span class="o">/</span> <span class="n">meanrate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_abs</span><span class="p">(</span><span class="n">powers</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_leahy</span><span class="p">(</span><span class="n">powers</span><span class="p">)</span> <span class="o">*</span> <span class="n">meanrate</span>

    <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;frac&quot;</span><span class="p">):</span>
        <span class="n">to_norm</span> <span class="o">=</span> <span class="n">to_frac</span>
    <span class="k">elif</span> <span class="n">kind</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;abs&quot;</span><span class="p">):</span>
        <span class="n">to_norm</span> <span class="o">=</span> <span class="n">to_abs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only &#39;frac&#39; or &#39;abs&#39; rms are supported.&quot;</span><span class="p">)</span>

    <span class="n">poisson</span> <span class="o">=</span> <span class="n">to_norm</span><span class="p">(</span><span class="n">poisson_noise_unnorm</span><span class="p">)</span>
    <span class="n">powers</span> <span class="o">=</span> <span class="n">to_norm</span><span class="p">(</span><span class="n">unnorm_powers</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">get_rms_from_rms_norm_periodogram</span><span class="p">(</span><span class="n">powers</span><span class="p">,</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">rms_calculation</span><span class="p">(</span>
    <span class="n">unnorm_powers</span><span class="p">,</span>
    <span class="n">min_freq</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="p">,</span>
    <span class="n">nphots</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">M_freqs</span><span class="p">,</span>
    <span class="n">K_freqs</span><span class="p">,</span>
    <span class="n">freq_bins</span><span class="p">,</span>
    <span class="n">poisson_noise_unnorm</span><span class="p">,</span>
    <span class="n">deadtime</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the fractional rms amplitude in the given power or cross spectrum</span>

<span class="sd">    NOTE: all array quantities are already in the correct energy range</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unnorm_powers: array of float</span>
<span class="sd">        unnormalised power or cross spectrum, the array has already been</span>
<span class="sd">        filtered for the given frequency range</span>

<span class="sd">    min_freq: float</span>
<span class="sd">        The lower frequency bound for the calculation (from the freq grid).</span>

<span class="sd">    max_freq: float</span>
<span class="sd">        The upper frequency bound for the calculation (from the freq grid).</span>

<span class="sd">    nphots: float</span>
<span class="sd">        Number of photons for the full power or cross spectrum</span>

<span class="sd">    T: float</span>
<span class="sd">        Time length of the light curve</span>

<span class="sd">    M_freq: scalar or array of float</span>
<span class="sd">        If scalar, it is the number of segments in the AveragedCrossspectrum</span>
<span class="sd">        If array, it is the number of segments times the rebinning sample</span>
<span class="sd">        in the given frequency range.</span>

<span class="sd">    K_freq: scalar or array of float</span>
<span class="sd">        If scalar, the power or cross spectrum is not rebinned (K_freq = 1)</span>
<span class="sd">        If array,  the power or cross spectrum is rebinned and it is the</span>
<span class="sd">        rebinned sample in the given frequency range.</span>

<span class="sd">    freq_bins: integer</span>
<span class="sd">        if the cross or power spectrum is rebinned freq_bins = 1,</span>
<span class="sd">        if it NOT rebinned freq_bins is the number of frequency bins</span>
<span class="sd">        in the given frequency range.</span>

<span class="sd">    poisson_noise_unnorm : float</span>
<span class="sd">        This is the Poisson noise level unnormalised.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    deadtime: float</span>
<span class="sd">        Deadtime of the instrument</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms: float</span>
<span class="sd">        The fractional rms amplitude contained between ``min_freq`` and</span>
<span class="sd">        ``max_freq``.</span>

<span class="sd">    rms_err: float</span>
<span class="sd">        The error on the fractional rms amplitude.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;The rms_calculation function is deprecated. Use get_rms_from_unnorm_periodogram instead.&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">rms_norm_powers</span> <span class="o">=</span> <span class="n">unnorm_powers</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">T</span> <span class="o">/</span> <span class="n">nphots</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">rms_poisson_noise</span> <span class="o">=</span> <span class="n">poisson_noise_unnorm</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">T</span> <span class="o">/</span> <span class="n">nphots</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">df</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">T</span> <span class="o">*</span> <span class="n">K_freqs</span>

    <span class="n">rms</span><span class="p">,</span> <span class="n">rms_err</span> <span class="o">=</span> <span class="n">get_rms_from_rms_norm_periodogram</span><span class="p">(</span>
        <span class="n">rms_norm_powers</span><span class="p">,</span> <span class="n">rms_poisson_noise</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">M_freqs</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">rms</span><span class="p">,</span> <span class="n">rms_err</span>


<span class="k">def</span><span class="w"> </span><span class="nf">error_on_averaged_cross_spectrum</span><span class="p">(</span>
    <span class="n">cross_power</span><span class="p">,</span> <span class="n">seg_power</span><span class="p">,</span> <span class="n">ref_power</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">,</span> <span class="n">seg_power_noise</span><span class="p">,</span> <span class="n">ref_power_noise</span><span class="p">,</span> <span class="n">common_ref</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Error on cross spectral quantities.</span>

<span class="sd">    `Ingram 2019&lt;https://ui.adsabs.harvard.edu/abs/2019MNRAS.489.3927I/abstract&gt;`__ details</span>
<span class="sd">    the derivation of the corrected formulas when the subject band is included in the reference</span>
<span class="sd">    band (and photons are presents in both bands, so this does _not_ involve overlapping bands from</span>
<span class="sd">    different detectors).</span>
<span class="sd">    The keyword argument ``common_ref`` indicates if the reference band also contains the photons</span>
<span class="sd">    of the subject band.</span>

<span class="sd">    Note: this is only valid for a very large number of averaged powers.</span>
<span class="sd">    Beware if n_ave &lt; 50 or so.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    seg_power : float `np.array`</span>
<span class="sd">        sub-band periodogram</span>
<span class="sd">    ref_power : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    seg_power_noise : float</span>
<span class="sd">        Poisson noise level of the sub-band periodogram</span>
<span class="sd">    ref_power_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        number of intervals that have been averaged to obtain the input spectra</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    common_ref : bool, default False</span>
<span class="sd">        Are data in the sub-band also included in the reference band?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dRe : float `np.array`</span>
<span class="sd">        Error on the real part of the cross spectrum</span>
<span class="sd">    dIm : float `np.array`</span>
<span class="sd">        Error on the imaginary part of the cross spectrum</span>
<span class="sd">    dphi : float `np.array`</span>
<span class="sd">        Error on the angle (or phase lag)</span>
<span class="sd">    dG : float `np.array`</span>
<span class="sd">        Error on the modulus of the cross spectrum</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_ave</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_ave</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_ave</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">n_ave</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">30</span>
    <span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;n_ave is below 30. Please note that the error bars &quot;</span>
            <span class="s2">&quot;on the quantities derived from the cross spectrum &quot;</span>
            <span class="s2">&quot;are only reliable for a large number of averaged &quot;</span>
            <span class="s2">&quot;powers.&quot;</span>
        <span class="p">)</span>
    <span class="n">two_n_ave</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ave</span>
    <span class="k">if</span> <span class="n">common_ref</span><span class="p">:</span>
        <span class="n">Gsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">cross_power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">cross_power</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
        <span class="n">bsq</span> <span class="o">=</span> <span class="n">bias_term</span><span class="p">(</span><span class="n">seg_power</span><span class="p">,</span> <span class="n">ref_power</span><span class="p">,</span> <span class="n">seg_power_noise</span><span class="p">,</span> <span class="n">ref_power_noise</span><span class="p">,</span> <span class="n">n_ave</span><span class="p">)</span>
        <span class="n">frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gsq</span> <span class="o">-</span> <span class="n">bsq</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ref_power</span> <span class="o">-</span> <span class="n">ref_power_noise</span><span class="p">)</span>
        <span class="n">power_over_2n</span> <span class="o">=</span> <span class="n">ref_power</span> <span class="o">/</span> <span class="n">two_n_ave</span>

        <span class="c1"># Eq. 18</span>
        <span class="n">dRe</span> <span class="o">=</span> <span class="n">dIm</span> <span class="o">=</span> <span class="n">dG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">power_over_2n</span> <span class="o">*</span> <span class="p">(</span><span class="n">seg_power</span> <span class="o">-</span> <span class="n">frac</span><span class="p">))</span>
        <span class="c1"># Eq. 19</span>
        <span class="n">dphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">power_over_2n</span> <span class="o">*</span> <span class="p">(</span><span class="n">seg_power</span> <span class="o">/</span> <span class="p">(</span><span class="n">Gsq</span> <span class="o">-</span> <span class="n">bsq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">ref_power</span> <span class="o">-</span> <span class="n">ref_power_noise</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">PrPs</span> <span class="o">=</span> <span class="n">ref_power</span> <span class="o">*</span> <span class="n">seg_power</span>
        <span class="n">dRe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">PrPs</span> <span class="o">+</span> <span class="n">cross_power</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cross_power</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">two_n_ave</span><span class="p">)</span>
        <span class="n">dIm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">PrPs</span> <span class="o">-</span> <span class="n">cross_power</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cross_power</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">two_n_ave</span><span class="p">)</span>

        <span class="n">gsq</span> <span class="o">=</span> <span class="n">raw_coherence</span><span class="p">(</span>
            <span class="n">cross_power</span><span class="p">,</span>
            <span class="n">seg_power</span><span class="p">,</span>
            <span class="n">ref_power</span><span class="p">,</span>
            <span class="n">seg_power_noise</span><span class="p">,</span>
            <span class="n">ref_power_noise</span><span class="p">,</span>
            <span class="n">n_ave</span><span class="p">,</span>
            <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">dphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gsq</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gsq</span> <span class="o">*</span> <span class="n">n_ave</span><span class="p">))</span>
        <span class="n">dG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">PrPs</span> <span class="o">/</span> <span class="n">n_ave</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dRe</span><span class="p">,</span> <span class="n">dIm</span><span class="p">,</span> <span class="n">dphi</span><span class="p">,</span> <span class="n">dG</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cross_to_covariance</span><span class="p">(</span><span class="n">cross_power</span><span class="p">,</span> <span class="n">ref_power</span><span class="p">,</span> <span class="n">ref_power_noise</span><span class="p">,</span> <span class="n">delta_nu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a cross spectrum into a covariance spectrum.</span>

<span class="sd">    Covariance:</span>
<span class="sd">    Wilkinson &amp; Uttley 2009, MNRAS, 397, 666</span>

<span class="sd">    Complex covariance:</span>
<span class="sd">    Mastroserio et al. 2018, MNRAS, 475, 4027</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cross_power : complex `np.array`</span>
<span class="sd">        cross spectrum</span>
<span class="sd">    ref_power : float `np.array`</span>
<span class="sd">        reference-band periodogram</span>
<span class="sd">    ref_power_noise : float</span>
<span class="sd">        Poisson noise level of the reference-band periodogram</span>
<span class="sd">    delta_nu : float or `np.array`</span>
<span class="sd">        spectral resolution. Can be a float, or an array if the spectral</span>
<span class="sd">        resolution is not constant throughout the periodograms</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    covariance: complex `np.array`</span>
<span class="sd">        The cross spectrum, normalized as a covariance.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cross_power</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta_nu</span> <span class="o">/</span> <span class="p">(</span><span class="n">ref_power</span> <span class="o">-</span> <span class="n">ref_power_noise</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_which_segment_idx_fun</span><span class="p">(</span><span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select which segment index function from ``gti.py`` to use.</span>

<span class="sd">    If ``binned`` is ``False``, call the unbinned function.</span>

<span class="sd">    If ``binned`` is not ``True``, call the binned function.</span>

<span class="sd">    Note that in the binned function ``dt`` is an optional parameter.</span>
<span class="sd">    We pass it if the user specifies it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make function interface equal (fluxes gets ignored)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binned</span><span class="p">:</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">generate_indices_of_segment_boundaries_unbinned</span>

        <span class="c1"># Define a new function, make sure that, by default, the sort check</span>
        <span class="c1"># is disabled.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">check_sorted</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;check_sorted&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">generate_indices_of_segment_boundaries_unbinned</span><span class="p">(</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">check_sorted</span><span class="o">=</span><span class="n">check_sorted</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Define a new function, so that we can pass the correct dt as an</span>
        <span class="c1"># argument.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">generate_indices_of_segment_boundaries_binned</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fun</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_average_ctrate</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average count rate during the observation.</span>

<span class="sd">    This function finds the same segments that the averaged periodogram</span>
<span class="sd">    functions (``avg_cs_from_iterables``, ``avg_pds_from_iterables`` etc) will</span>
<span class="sd">    use, and returns the mean count rate.</span>
<span class="sd">    If ``counts`` is ``None``, the input times are interpreted as events.</span>
<span class="sd">    Otherwise, the number of events is taken from ``counts``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : float `np.array`</span>
<span class="sd">        Array of times</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        good time intervals</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        length of segments</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    counts : float `np.array`, default None</span>
<span class="sd">        Array of counts per bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ctrate : float</span>
<span class="sd">        The average count rate in the segments that are used for the analysis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; times = np.sort(np.random.uniform(0, 1000, 1000))</span>
<span class="sd">    &gt;&gt;&gt; gti = np.asanyarray([[0, 1000]])</span>
<span class="sd">    &gt;&gt;&gt; counts, _ = np.histogram(times, bins=np.linspace(0, 1000, 11))</span>
<span class="sd">    &gt;&gt;&gt; bin_times = np.arange(50, 1000, 100)</span>
<span class="sd">    &gt;&gt;&gt; assert get_average_ctrate(bin_times, gti, 1000, counts=counts) == 1.0</span>
<span class="sd">    &gt;&gt;&gt; assert get_average_ctrate(times, gti, 1000) == 1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_ph</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_intvs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">binned</span> <span class="o">=</span> <span class="n">counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_which_segment_idx_fun</span><span class="p">(</span><span class="n">binned</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="n">func</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">binned</span><span class="p">:</span>
            <span class="n">n_ph</span> <span class="o">+=</span> <span class="n">idx1</span> <span class="o">-</span> <span class="n">idx0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_ph</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">])</span>
        <span class="n">n_intvs</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_intvs</span> <span class="o">*</span> <span class="n">segment_size</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_flux_iterable_from_segments</span><span class="p">(</span>
    <span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">n_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fluxes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get fluxes from different segments of the observation.</span>

<span class="sd">    If ``fluxes`` is ``None``, the input times are interpreted as events, and</span>
<span class="sd">    they are split into many binned series of length ``segment_size`` with</span>
<span class="sd">    ``n_bin`` bins.</span>

<span class="sd">    If ``fluxes`` is an array, the number of events corresponding to each time</span>
<span class="sd">    bin is taken from ``fluxes``</span>

<span class="sd">    Therefore, at least one of either ``n_bin`` and ``fluxes`` needs to be</span>
<span class="sd">    specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : float `np.array`</span>
<span class="sd">        Array of times</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        good time intervals</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        length of segments. If ``None``, the full light curve is used.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    n_bin : int, default None</span>
<span class="sd">        Number of bins to divide the ``segment_size`` in</span>
<span class="sd">    fluxes : float `np.array`, default None</span>
<span class="sd">        Array of fluxes.</span>
<span class="sd">    errors : float `np.array`, default None</span>
<span class="sd">        Array of error bars corresponding to the flux values above.</span>
<span class="sd">    dt : float, default None</span>
<span class="sd">        Time resolution of the light curve used to produce periodograms</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    flux : `np.array`</span>
<span class="sd">        Array of fluxes</span>
<span class="sd">    err : `np.array`</span>
<span class="sd">        (optional) if ``errors`` is None, an array of errors in the segment</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fluxes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_bin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;At least one between fluxes (if light curve) and &quot;</span> <span class="s2">&quot;n_bin (if events) has to be set&quot;</span>
        <span class="p">)</span>

    <span class="n">binned</span> <span class="o">=</span> <span class="n">fluxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">cast_kind</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">binned</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="mi">100</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
        <span class="n">fluxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">fluxes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">fluxes</span><span class="p">):</span>
            <span class="n">cast_kind</span> <span class="o">=</span> <span class="nb">complex</span>

    <span class="k">if</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segment_size</span> <span class="o">=</span> <span class="n">gti</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gti</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">gti</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">gti</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">]]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">_which_segment_idx_fun</span><span class="p">(</span><span class="n">binned</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="n">fun</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx1</span> <span class="o">-</span> <span class="n">idx0</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">yield</span> <span class="kc">None</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">binned</span><span class="p">:</span>
            <span class="c1"># astype here serves to avoid integer rounding issues in Windows,</span>
            <span class="c1"># where long is a 32-bit integer.</span>
            <span class="n">cts</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span>
                <span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="n">n_bin</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">cts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cts</span> <span class="o">=</span> <span class="n">fluxes</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cast_kind</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cts</span> <span class="o">=</span> <span class="n">cts</span><span class="p">,</span> <span class="n">errors</span><span class="p">[</span><span class="n">idx0</span><span class="p">:</span><span class="n">idx1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cast_kind</span><span class="p">)</span>

        <span class="k">yield</span> <span class="n">cts</span>


<span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_safe_array_slice_indices</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">input_center_idx</span><span class="p">,</span> <span class="n">nbins</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the indices needed to extract a n-bin slice of an array, centered at an index.</span>

<span class="sd">    Let us say we have an array of size ``input_size`` and we want to extract a slice of</span>
<span class="sd">    ``nbins`` centered at index ``input_center_idx``. We should be robust when the slice goes</span>
<span class="sd">    beyond the edges of the input array, possibly leaving missing values in the output array.</span>
<span class="sd">    This function calculates the indices needed to extract the slice from the input array, and</span>
<span class="sd">    the indices in the output array that will be filled.</span>

<span class="sd">    In the most common case, the slice is entirely contained within the input array, so that the</span>
<span class="sd">    output slice will just be ``[0:nbins]`` and the input slice</span>
<span class="sd">    ``[input_center_idx - nbins // 2: input_center_idx - nbins // 2 + nbins]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_size : int</span>
<span class="sd">        Input array size</span>
<span class="sd">    center_idx : int</span>
<span class="sd">        Index of the center of the slice</span>
<span class="sd">    nbins : int</span>
<span class="sd">        Number of bins to extract</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    input_slice : list</span>
<span class="sd">        Indices to extract the slice from the input array</span>
<span class="sd">    output_slice : list</span>
<span class="sd">        Indices to fill the output array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _safe_array_slice_indices(input_size=10, input_center_idx=5, nbins=3)</span>
<span class="sd">    ([4, 7], [0, 3])</span>

<span class="sd">    If the slice goes beyond the right edge: the output slice will only cover</span>
<span class="sd">    the first two bins of the output array, and up to the end of the input array.</span>
<span class="sd">    &gt;&gt;&gt; _safe_array_slice_indices(input_size=6, input_center_idx=5, nbins=3)</span>
<span class="sd">    ([4, 6], [0, 2])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">minbin</span> <span class="o">=</span> <span class="n">input_center_idx</span> <span class="o">-</span> <span class="n">nbins</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">maxbin</span> <span class="o">=</span> <span class="n">minbin</span> <span class="o">+</span> <span class="n">nbins</span>

    <span class="k">if</span> <span class="n">minbin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">output_slice</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">minbin</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">input_size</span> <span class="o">-</span> <span class="n">minbin</span><span class="p">)]</span>
        <span class="n">input_slice</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">minbin</span> <span class="o">+</span> <span class="n">nbins</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">maxbin</span> <span class="o">&gt;</span> <span class="n">input_size</span><span class="p">:</span>
        <span class="n">output_slice</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">-</span> <span class="p">(</span><span class="n">maxbin</span> <span class="o">-</span> <span class="n">input_size</span><span class="p">)]</span>
        <span class="n">input_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">minbin</span><span class="p">,</span> <span class="n">input_size</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_slice</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbins</span><span class="p">]</span>
        <span class="n">input_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">minbin</span><span class="p">,</span> <span class="n">maxbin</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">input_slice</span><span class="p">,</span> <span class="n">output_slice</span>


<span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_pds_slice_around_freq</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">powers</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a slice of PDS around a given frequency.</span>

<span class="sd">    This function extracts a slice of the power spectrum around a given frequency.</span>
<span class="sd">    The slice has a length of ``nbins``. If the slice goes beyond the edges of the</span>
<span class="sd">    power spectrum, the missing values are filled with NaNs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freqs : np.array</span>
<span class="sd">        Array of frequencies, the same for all powers</span>
<span class="sd">    powers : np.array</span>
<span class="sd">        Array of powers</span>
<span class="sd">    f0 : float</span>
<span class="sd">        Central frequency</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    nbins : int, default 100</span>
<span class="sd">        Number of bins to extract</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; freqs = np.arange(1, 100) * 0.1</span>
<span class="sd">    &gt;&gt;&gt; powers = 10 / freqs</span>
<span class="sd">    &gt;&gt;&gt; f0 = 0.3</span>
<span class="sd">    &gt;&gt;&gt; p = extract_pds_slice_around_freq(freqs, powers, f0)</span>
<span class="sd">    &gt;&gt;&gt; assert np.isnan(p[0])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.any(np.isnan(p[48:]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">powers</span><span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># fchunk = np.zeros(nbins)</span>

    <span class="n">start_f_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">f0</span><span class="p">)</span>

    <span class="n">input_slice</span><span class="p">,</span> <span class="n">output_slice</span> <span class="o">=</span> <span class="n">_safe_array_slice_indices</span><span class="p">(</span><span class="n">powers</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">start_f_idx</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
    <span class="n">chunk</span><span class="p">[</span><span class="n">output_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">output_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">powers</span><span class="p">[</span><span class="n">input_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">input_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">chunk</span>


<span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_shift_and_average_core</span><span class="p">(</span><span class="n">input_array_list</span><span class="p">,</span> <span class="n">weight_list</span><span class="p">,</span> <span class="n">center_indices</span><span class="p">,</span> <span class="n">nbins</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Core function to shift_and_add, JIT-compiled for your convenience.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_array_list : list of np.array</span>
<span class="sd">        List of input arrays</span>
<span class="sd">    weight_list : list of float</span>
<span class="sd">        List of weights for each input array</span>
<span class="sd">    center_indices : list of int</span>
<span class="sd">        Central indices of the slice of each input array to be summed</span>
<span class="sd">    nbins : int</span>
<span class="sd">        Number of bins to extract around the central index of each input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output_array : np.array</span>
<span class="sd">        Average of the input arrays, weighted by the weights</span>
<span class="sd">    sum_of_weights : np.array</span>
<span class="sd">        Sum of the weights at each output bin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_size</span> <span class="o">=</span> <span class="n">input_array_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">output_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="n">sum_of_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">center_indices</span><span class="p">,</span> <span class="n">input_array_list</span><span class="p">,</span> <span class="n">weight_list</span><span class="p">):</span>
        <span class="n">input_slice</span><span class="p">,</span> <span class="n">output_slice</span> <span class="o">=</span> <span class="n">_safe_array_slice_indices</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">input_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output_array</span><span class="p">[</span><span class="n">output_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">input_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span>

            <span class="n">sum_of_weights</span><span class="p">[</span><span class="n">output_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>

    <span class="n">output_array</span> <span class="o">=</span> <span class="n">output_array</span> <span class="o">/</span> <span class="n">sum_of_weights</span>

    <span class="k">return</span> <span class="n">output_array</span><span class="p">,</span> <span class="n">sum_of_weights</span>


<span class="k">def</span><span class="w"> </span><span class="nf">shift_and_add</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">power_list</span><span class="p">,</span> <span class="n">f0_list</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">rebin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a list of power spectra, centered on different frequencies.</span>

<span class="sd">    This is the basic operation for the shift-and-add operation used to track</span>
<span class="sd">    kHz QPOs in X-ray binaries (e.g. Mndez et al. 1998, ApJ, 494, 65).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freqs : np.array</span>
<span class="sd">        Array of frequencies, the same for all powers. Must be sorted and on a uniform</span>
<span class="sd">        grid.</span>
<span class="sd">    power_list : list of np.array</span>
<span class="sd">        List of power spectra. Each power spectrum must have the same length</span>
<span class="sd">        as the frequency array.</span>
<span class="sd">    f0_list : list of float</span>
<span class="sd">        List of central frequencies</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    nbins : int, default 100</span>
<span class="sd">        Number of bins to extract</span>
<span class="sd">    rebin : int, default None</span>
<span class="sd">        Rebin the final spectrum by this factor. At the moment, the rebinning</span>
<span class="sd">        is linear.</span>
<span class="sd">    df : float, default None</span>
<span class="sd">        Frequency resolution of the power spectra. If not given, it is calculated</span>
<span class="sd">        from the input frequencies.</span>
<span class="sd">    M : int or list of int, default None</span>
<span class="sd">        Number of segments used to calculate each power spectrum. If a list is</span>
<span class="sd">        given, it must have the same length as the power list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : np.array</span>
<span class="sd">        Array of output frequencies</span>
<span class="sd">    p : np.array</span>
<span class="sd">        Array of output powers</span>
<span class="sd">    n : np.array</span>
<span class="sd">        Number of contributing power spectra at each frequency</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; power_list = [[2, 5, 2, 2, 2], [1, 1, 5, 1, 1], [3, 3, 3, 5, 3]]</span>
<span class="sd">    &gt;&gt;&gt; freqs = np.arange(5) * 0.1</span>
<span class="sd">    &gt;&gt;&gt; f0_list = [0.1, 0.2, 0.3, 0.4]</span>
<span class="sd">    &gt;&gt;&gt; f, p, n = shift_and_add(freqs, power_list, f0_list, nbins=5)</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(n, [2, 3, 3, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; assert np.array_equal(p, [2. , 2. , 5. , 2. , 1.5])</span>
<span class="sd">    &gt;&gt;&gt; assert np.allclose(f, [0.05, 0.15, 0.25, 0.35, 0.45])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if the input list of power contains numpy arrays</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">power_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;size&quot;</span><span class="p">):</span>
        <span class="n">power_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">power_list</span><span class="p">)</span>
    <span class="c1"># input_size = np.size(power_list[0])</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>

    <span class="c1"># mid_idx = np.searchsorted(freqs, np.mean(f0_list))</span>
    <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">power_list</span><span class="p">))</span> <span class="o">*</span> <span class="n">M</span>

    <span class="n">center_f_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">f0_list</span><span class="p">)</span>

    <span class="n">final_powers</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">_shift_and_average_core</span><span class="p">(</span><span class="n">power_list</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">center_f_indices</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">final_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">nbins</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">nbins</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span>
    <span class="n">final_freqs</span> <span class="o">=</span> <span class="n">final_freqs</span> <span class="o">-</span> <span class="p">(</span><span class="n">final_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">final_freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f0_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rebin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rebin_data</span><span class="p">(</span><span class="n">final_freqs</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">rebin</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">final_freqs</span><span class="p">,</span> <span class="n">final_powers</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rebin_data</span><span class="p">(</span><span class="n">final_freqs</span><span class="p">,</span> <span class="n">final_powers</span><span class="p">,</span> <span class="n">rebin</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>
        <span class="n">final_powers</span> <span class="o">=</span> <span class="n">final_powers</span> <span class="o">/</span> <span class="n">rebin</span>

    <span class="k">return</span> <span class="n">final_freqs</span><span class="p">,</span> <span class="n">final_powers</span><span class="p">,</span> <span class="n">count</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_pds_from_iterable</span><span class="p">(</span>
    <span class="n">flux_iterable</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span> <span class="n">use_common_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_subcs</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average periodogram from an iterable of light curves</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flux_iterable : `iterable` of `np.array`s or of tuples (`np.array`, `np.array`)</span>
<span class="sd">        Iterable providing either equal-length series of count measurements,</span>
<span class="sd">        or of tuples (fluxes, errors). They must all be of the same length.</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the light curves used to produce periodograms</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    norm : str, default &quot;frac&quot;</span>
<span class="sd">        The normalization of the periodogram. &quot;abs&quot; is absolute rms, &quot;frac&quot; is</span>
<span class="sd">        fractional rms, &quot;leahy&quot; is Leahy+83 normalization, and &quot;none&quot; is the</span>
<span class="sd">        unnormalized periodogram</span>
<span class="sd">    use_common_mean : bool, default True</span>
<span class="sd">        The mean of the light curve can be estimated in each interval, or on</span>
<span class="sd">        the full light curve. This gives different results (Alston+2013).</span>
<span class="sd">        Here we assume the mean is calculated on the full light curve, but</span>
<span class="sd">        the user can set ``use_common_mean`` to False to calculate it on a</span>
<span class="sd">        per-segment basis.</span>
<span class="sd">    silent : bool, default False</span>
<span class="sd">        Silence the progress bars</span>
<span class="sd">    return_subcs : bool, default False</span>
<span class="sd">        Return all sub spectra from each light curve chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : :class:`astropy.table.Table`</span>
<span class="sd">        Table containing the following columns:</span>
<span class="sd">        freq : `np.array`</span>
<span class="sd">            The periodogram frequencies</span>
<span class="sd">        power : `np.array`</span>
<span class="sd">            The normalized periodogram powers</span>
<span class="sd">        unnorm_power : `np.array`</span>
<span class="sd">            The unnormalized periodogram powers</span>

<span class="sd">        And a number of other useful diagnostics in the metadata, including</span>
<span class="sd">        all attributes needed to allocate Powerspectrum objects, such as all</span>
<span class="sd">        the input arguments of this function (``dt``, ``segment_size``), and,</span>
<span class="sd">        e.g.</span>
<span class="sd">        n : int</span>
<span class="sd">            the number of bins in the light curves used in each segment</span>
<span class="sd">        m : int</span>
<span class="sd">            the number of averaged periodograms</span>
<span class="sd">        mean : float</span>
<span class="sd">            the mean flux</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">local_show_progress</span> <span class="o">=</span> <span class="n">show_progress</span>
    <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">local_show_progress</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>

    <span class="c1"># Initialize stuff</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_ave</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">sum_of_photons</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">common_variance</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
        <span class="n">subcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unnorm_subcs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">flux</span> <span class="ow">in</span> <span class="n">local_show_progress</span><span class="p">(</span><span class="n">flux_iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># If the iterable returns the uncertainty, use it to calculate the</span>
        <span class="c1"># variance.</span>
        <span class="n">variance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">flux</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">flux</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Calculate the FFT</span>
        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">size</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>

        <span class="c1"># This will only be used by the Leahy normalization, so only if</span>
        <span class="c1"># the input light curve is in units of counts/bin</span>
        <span class="n">n_ph</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="p">(</span><span class="n">ft</span> <span class="o">*</span> <span class="n">ft</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Accumulate the sum of means and variances, to get the final mean and</span>
        <span class="c1"># variance the end</span>
        <span class="n">sum_of_photons</span> <span class="o">+=</span> <span class="n">n_ph</span>

        <span class="k">if</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">common_variance</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">common_variance</span><span class="p">,</span> <span class="n">variance</span><span class="p">)</span>

        <span class="c1"># In the first loop, define the frequency and the freq. interval &gt; 0</span>
        <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fgt0</span> <span class="o">=</span> <span class="n">positive_fft_bins</span><span class="p">(</span><span class="n">n_bin</span><span class="p">)</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">fftfreq</span><span class="p">(</span><span class="n">n_bin</span><span class="p">,</span> <span class="n">dt</span><span class="p">)[</span><span class="n">fgt0</span><span class="p">]</span>

        <span class="c1"># No need for the negative frequencies</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">unnorm_power</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>

        <span class="c1"># If the user wants to normalize using the mean of the total</span>
        <span class="c1"># lightcurve, normalize it here</span>
        <span class="n">cs_seg</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_common_mean</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="n">n_bin</span>

            <span class="n">cs_seg</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                <span class="n">unnorm_power</span><span class="p">,</span>
                <span class="n">dt</span><span class="p">,</span>
                <span class="n">n_bin</span><span class="p">,</span>
                <span class="n">mean</span><span class="p">,</span>
                <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                <span class="n">variance</span><span class="o">=</span><span class="n">variance</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Accumulate the total sum cross spectrum</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">cross</span><span class="p">,</span> <span class="n">cs_seg</span><span class="p">)</span>
        <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">unnorm_cross</span><span class="p">,</span> <span class="n">unnorm_power</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
            <span class="n">subcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cs_seg</span><span class="p">)</span>
            <span class="n">unnorm_subcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">)</span>

        <span class="n">n_ave</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># If there were no good intervals, return None</span>
    <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Calculate the mean number of photons per chunk</span>
    <span class="n">n_ph</span> <span class="o">=</span> <span class="n">sum_of_photons</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="c1"># Calculate the mean number of photons per bin</span>
    <span class="n">common_mean</span> <span class="o">=</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="n">n_bin</span>

    <span class="k">if</span> <span class="n">common_variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Note: the variances we summed were means, not sums.</span>
        <span class="c1"># Hence M, not M*n_bin</span>
        <span class="n">common_variance</span> <span class="o">/=</span> <span class="n">n_ave</span>

    <span class="c1"># Transform a sum into the average</span>
    <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="n">unnorm_cross</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">cross</span> <span class="o">/</span> <span class="n">n_ave</span>

    <span class="c1"># Final normalization (If not done already!)</span>
    <span class="k">if</span> <span class="n">use_common_mean</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">,</span> <span class="n">common_mean</span><span class="p">,</span> <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="n">common_variance</span>
        <span class="p">)</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">unnorm_cross</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcs</span><span class="p">)):</span>
                <span class="n">subcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">Table</span><span class="p">()</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;unnorm_power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_cross</span>
    <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="n">n_bin</span><span class="p">,</span>
            <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="n">n_ave</span><span class="p">,</span>
            <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="n">dt</span><span class="p">,</span>
            <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span>
            <span class="s2">&quot;df&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">),</span>
            <span class="s2">&quot;nphots&quot;</span><span class="p">:</span> <span class="n">n_ph</span><span class="p">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">common_mean</span><span class="p">,</span>
            <span class="s2">&quot;variance&quot;</span><span class="p">:</span> <span class="n">common_variance</span><span class="p">,</span>
            <span class="s2">&quot;segment_size&quot;</span><span class="p">:</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;subcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subcs</span>
        <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;unnorm_subcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_subcs</span>

    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_cs_from_iterables_quick</span><span class="p">(</span><span class="n">flux_iterable1</span><span class="p">,</span> <span class="n">flux_iterable2</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like `avg_cs_from_iterables`, with default options that make it quick.</span>

<span class="sd">    Assumes that:</span>

<span class="sd">    * the flux iterables return counts/bin, no other units</span>
<span class="sd">    * the mean is calculated over the whole light curve, and normalization</span>
<span class="sd">      is done at the end</span>
<span class="sd">    * no auxiliary PDSs are returned</span>
<span class="sd">    * only positive frequencies are returned</span>
<span class="sd">    * the spectrum is complex, no real parts or absolutes</span>
<span class="sd">    * no progress bars</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flux_iterable1 : `iterable` of `np.array`s or of tuples (`np.array`, `np.array`)</span>
<span class="sd">        Iterable providing either equal-length series of count measurements, or</span>
<span class="sd">        of tuples (fluxes, errors). They must all be of the same length.</span>
<span class="sd">    flux_iterable2 : `iterable` of `np.array`s or of tuples (`np.array`, `np.array`)</span>
<span class="sd">        Same as ``flux_iterable1``, for the reference channel</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the light curves used to produce periodograms</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    norm : str, default &quot;frac&quot;</span>
<span class="sd">        The normalization of the periodogram. &quot;abs&quot; is absolute rms, &quot;frac&quot; is</span>
<span class="sd">        fractional rms, &quot;leahy&quot; is Leahy+83 normalization, and &quot;none&quot; is the</span>
<span class="sd">        unnormalized periodogram</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : :class:`astropy.table.Table`</span>
<span class="sd">        Table containing the following columns:</span>
<span class="sd">        freq : `np.array`</span>
<span class="sd">            The periodogram frequencies</span>
<span class="sd">        power : `np.array`</span>
<span class="sd">            The normalized periodogram powers</span>
<span class="sd">        unnorm_power : `np.array`</span>
<span class="sd">            The unnormalized periodogram powers</span>

<span class="sd">        And a number of other useful diagnostics in the metadata, including</span>
<span class="sd">        all attributes needed to allocate Crossspectrum objects, such as all</span>
<span class="sd">        the input arguments of this function (``dt``, ``segment_size``), and,</span>
<span class="sd">        e.g.</span>
<span class="sd">        n : int</span>
<span class="sd">            the number of bins in the light curves used in each segment</span>
<span class="sd">        m : int</span>
<span class="sd">            the number of averaged periodograms</span>
<span class="sd">        mean : float</span>
<span class="sd">            the mean flux (geometrical average of the mean fluxes in the two</span>
<span class="sd">            channels)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize stuff</span>
    <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_ave</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">sum_of_photons1</span> <span class="o">=</span> <span class="n">sum_of_photons2</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">flux1</span><span class="p">,</span> <span class="n">flux2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flux_iterable1</span><span class="p">,</span> <span class="n">flux_iterable2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flux1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">flux2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flux1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flux2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">flux1</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Calculate the sum of each light curve, to calculate the mean</span>
        <span class="n">n_ph1</span> <span class="o">=</span> <span class="n">flux1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_ph2</span> <span class="o">=</span> <span class="n">flux2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># At the first loop, we define the frequency array and the range of</span>
        <span class="c1"># positive frequency bins (after the first loop, cross will not be</span>
        <span class="c1"># None anymore)</span>
        <span class="k">if</span> <span class="n">unnorm_cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">fftfreq</span><span class="p">(</span><span class="n">n_bin</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">fgt0</span> <span class="o">=</span> <span class="n">positive_fft_bins</span><span class="p">(</span><span class="n">n_bin</span><span class="p">)</span>

        <span class="c1"># Calculate the FFTs</span>
        <span class="n">ft1</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">flux1</span><span class="p">)</span>
        <span class="n">ft2</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">flux2</span><span class="p">)</span>

        <span class="c1"># Calculate the unnormalized cross spectrum</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">ft1</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">ft2</span>

        <span class="c1"># Accumulate the sum to calculate the total mean of the lc</span>
        <span class="n">sum_of_photons1</span> <span class="o">+=</span> <span class="n">n_ph1</span>
        <span class="n">sum_of_photons2</span> <span class="o">+=</span> <span class="n">n_ph2</span>

        <span class="c1"># Take only positive frequencies</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">unnorm_power</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>

        <span class="c1"># Initialize or accumulate final averaged spectrum</span>
        <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">unnorm_cross</span><span class="p">,</span> <span class="n">unnorm_power</span><span class="p">)</span>

        <span class="n">n_ave</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># If no valid intervals were found, return only `None`s</span>
    <span class="k">if</span> <span class="n">unnorm_cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Calculate the mean number of photons per chunk</span>
    <span class="n">n_ph1</span> <span class="o">=</span> <span class="n">sum_of_photons1</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="n">n_ph2</span> <span class="o">=</span> <span class="n">sum_of_photons2</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="n">n_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_ph1</span> <span class="o">*</span> <span class="n">n_ph2</span><span class="p">)</span>
    <span class="c1"># Calculate the mean number of photons per bin</span>
    <span class="n">common_mean1</span> <span class="o">=</span> <span class="n">n_ph1</span> <span class="o">/</span> <span class="n">n_bin</span>
    <span class="n">common_mean2</span> <span class="o">=</span> <span class="n">n_ph2</span> <span class="o">/</span> <span class="n">n_bin</span>
    <span class="n">common_mean</span> <span class="o">=</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="n">n_bin</span>

    <span class="c1"># Transform the sums into averages</span>
    <span class="n">unnorm_cross</span> <span class="o">/=</span> <span class="n">n_ave</span>

    <span class="c1"># Finally, normalize the cross spectrum (only if not already done on an</span>
    <span class="c1"># interval-to-interval basis)</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
        <span class="n">unnorm_cross</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">,</span>
        <span class="n">n_bin</span><span class="p">,</span>
        <span class="n">common_mean</span><span class="p">,</span>
        <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">power_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># No negative frequencies</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">Table</span><span class="p">()</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;unnorm_power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_cross</span>
    <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="n">n_bin</span><span class="p">,</span>
            <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="n">n_ave</span><span class="p">,</span>
            <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="n">dt</span><span class="p">,</span>
            <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span>
            <span class="s2">&quot;df&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">),</span>
            <span class="s2">&quot;nphots&quot;</span><span class="p">:</span> <span class="n">n_ph</span><span class="p">,</span>
            <span class="s2">&quot;nphots1&quot;</span><span class="p">:</span> <span class="n">n_ph1</span><span class="p">,</span>
            <span class="s2">&quot;nphots2&quot;</span><span class="p">:</span> <span class="n">n_ph2</span><span class="p">,</span>
            <span class="s2">&quot;variance&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">common_mean</span><span class="p">,</span>
            <span class="s2">&quot;mean1&quot;</span><span class="p">:</span> <span class="n">common_mean1</span><span class="p">,</span>
            <span class="s2">&quot;mean2&quot;</span><span class="p">:</span> <span class="n">common_mean2</span><span class="p">,</span>
            <span class="s2">&quot;power_type&quot;</span><span class="p">:</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fullspec&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;segment_size&quot;</span><span class="p">:</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_cs_from_iterables</span><span class="p">(</span>
    <span class="n">flux_iterable1</span><span class="p">,</span>
    <span class="n">flux_iterable2</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span>
    <span class="n">use_common_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fullspec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">power_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">return_auxil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_subcs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the average cross spectrum from an iterable of light curves</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flux_iterable1 : `iterable` of `np.array`s or of tuples (`np.array`, `np.array`)</span>
<span class="sd">        Iterable providing either equal-length series of count measurements, or</span>
<span class="sd">        of tuples (fluxes, errors). They must all be of the same length.</span>
<span class="sd">    flux_iterable2 : `iterable` of `np.array`s or of tuples (`np.array`, `np.array`)</span>
<span class="sd">        Same as ``flux_iterable1``, for the reference channel</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the light curves used to produce periodograms</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    norm : str, default &quot;frac&quot;</span>
<span class="sd">        The normalization of the periodogram. &quot;abs&quot; is absolute rms, &quot;frac&quot; is</span>
<span class="sd">        fractional rms, &quot;leahy&quot; is Leahy+83 normalization, and &quot;none&quot; is the</span>
<span class="sd">        unnormalized periodogram</span>
<span class="sd">    use_common_mean : bool, default True</span>
<span class="sd">        The mean of the light curve can be estimated in each interval, or on</span>
<span class="sd">        the full light curve. This gives different results (Alston+2013).</span>
<span class="sd">        Here we assume the mean is calculated on the full light curve, but</span>
<span class="sd">        the user can set ``use_common_mean`` to False to calculate it on a</span>
<span class="sd">        per-segment basis.</span>
<span class="sd">    fullspec : bool, default False</span>
<span class="sd">        Return the full periodogram, including negative frequencies</span>
<span class="sd">    silent : bool, default False</span>
<span class="sd">        Silence the progress bars</span>
<span class="sd">    power_type : str, default &#39;all&#39;</span>
<span class="sd">        If &#39;all&#39;, give complex powers. If &#39;abs&#39;, the absolute value; if &#39;real&#39;,</span>
<span class="sd">        the real part</span>
<span class="sd">    return_auxil : bool, default False</span>
<span class="sd">        Return the auxiliary unnormalized PDSs from the two separate channels</span>
<span class="sd">    return_subcs : bool, default False</span>
<span class="sd">        Return all sub spectra from each light curve chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : :class:`astropy.table.Table`</span>
<span class="sd">        Table containing the following columns:</span>
<span class="sd">        freq : `np.array`</span>
<span class="sd">            The frequencies.</span>
<span class="sd">        power : `np.array`</span>
<span class="sd">            The normalized cross spectral powers.</span>
<span class="sd">        unnorm_power : `np.array`</span>
<span class="sd">            The unnormalized cross spectral power.</span>
<span class="sd">        unnorm_pds1 : `np.array`</span>
<span class="sd">            The unnormalized auxiliary PDS from channel 1. Only returned if</span>
<span class="sd">            ``return_auxil`` is ``True``.</span>
<span class="sd">        unnorm_pds2 : `np.array`</span>
<span class="sd">            The unnormalized auxiliary PDS from channel 2. Only returned if</span>
<span class="sd">            ``return_auxil`` is ``True``.</span>

<span class="sd">        And a number of other useful diagnostics in the metadata, including</span>
<span class="sd">        all attributes needed to allocate Crossspectrum objects, such as all</span>
<span class="sd">        the input arguments of this function (``dt``, ``segment_size``), and,</span>
<span class="sd">        e.g.</span>
<span class="sd">        n : int</span>
<span class="sd">            The number of bins in the light curves used in each segment.</span>
<span class="sd">        m : int</span>
<span class="sd">            The number of averaged periodograms.</span>
<span class="sd">        mean : float</span>
<span class="sd">            The mean flux (geometrical average of the mean fluxes in the two</span>
<span class="sd">            channels).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">local_show_progress</span> <span class="o">=</span> <span class="n">show_progress</span>
    <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">local_show_progress</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>

    <span class="c1"># Initialize stuff</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="n">unnorm_pds1</span> <span class="o">=</span> <span class="n">unnorm_pds2</span> <span class="o">=</span> <span class="n">pds1</span> <span class="o">=</span> <span class="n">pds2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_ave</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">sum_of_photons1</span> <span class="o">=</span> <span class="n">sum_of_photons2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">common_variance1</span> <span class="o">=</span> <span class="n">common_variance2</span> <span class="o">=</span> <span class="n">common_variance</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
        <span class="n">subcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unnorm_subcs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">flux1</span><span class="p">,</span> <span class="n">flux2</span> <span class="ow">in</span> <span class="n">local_show_progress</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">flux_iterable1</span><span class="p">,</span> <span class="n">flux_iterable2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">flux1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">flux2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flux1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flux2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Does the flux iterable return the uncertainty?</span>
        <span class="c1"># If so, define the variances</span>
        <span class="n">variance1</span> <span class="o">=</span> <span class="n">variance2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">flux1</span><span class="p">,</span> <span class="n">err1</span> <span class="o">=</span> <span class="n">flux1</span>
            <span class="n">variance1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">err1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux2</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">flux2</span><span class="p">,</span> <span class="n">err2</span> <span class="o">=</span> <span class="n">flux2</span>
            <span class="n">variance2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">err2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Only use the variance if both flux iterables define it.</span>
        <span class="k">if</span> <span class="n">variance1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">variance2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variance1</span> <span class="o">=</span> <span class="n">variance2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">common_variance1</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">common_variance1</span><span class="p">,</span> <span class="n">variance1</span><span class="p">)</span>
            <span class="n">common_variance2</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">common_variance2</span><span class="p">,</span> <span class="n">variance2</span><span class="p">)</span>

        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">flux1</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># At the first loop, we define the frequency array and the range of</span>
        <span class="c1"># positive frequency bins (after the first loop, cross will not be</span>
        <span class="c1"># None anymore)</span>
        <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">fftfreq</span><span class="p">(</span><span class="n">n_bin</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">fgt0</span> <span class="o">=</span> <span class="n">positive_fft_bins</span><span class="p">(</span><span class="n">n_bin</span><span class="p">)</span>

        <span class="c1"># Calculate the FFTs</span>
        <span class="n">ft1</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">flux1</span><span class="p">)</span>
        <span class="n">ft2</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">flux2</span><span class="p">)</span>

        <span class="c1"># Calculate the sum of each light curve chunk, to calculate the mean</span>
        <span class="n">n_ph1</span> <span class="o">=</span> <span class="n">flux1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_ph2</span> <span class="o">=</span> <span class="n">flux2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_ph1</span> <span class="o">*</span> <span class="n">n_ph2</span><span class="p">)</span>

        <span class="c1"># Calculate the unnormalized cross spectrum</span>
        <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">ft1</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">ft2</span>
        <span class="n">unnorm_pd1</span> <span class="o">=</span> <span class="n">unnorm_pd2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># If requested, calculate the auxiliary PDSs</span>
        <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
            <span class="n">unnorm_pd1</span> <span class="o">=</span> <span class="p">(</span><span class="n">ft1</span> <span class="o">*</span> <span class="n">ft1</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
            <span class="n">unnorm_pd2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ft2</span> <span class="o">*</span> <span class="n">ft2</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Accumulate the sum to calculate the total mean of the lc</span>
        <span class="n">sum_of_photons1</span> <span class="o">+=</span> <span class="n">n_ph1</span>
        <span class="n">sum_of_photons2</span> <span class="o">+=</span> <span class="n">n_ph2</span>

        <span class="c1"># Take only positive frequencies unless the user wants the full</span>
        <span class="c1"># spectrum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fullspec</span><span class="p">:</span>
            <span class="n">unnorm_power</span> <span class="o">=</span> <span class="n">unnorm_power</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
                <span class="n">unnorm_pd1</span> <span class="o">=</span> <span class="n">unnorm_pd1</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>
                <span class="n">unnorm_pd2</span> <span class="o">=</span> <span class="n">unnorm_pd2</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>

        <span class="n">cs_seg</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">)</span>
        <span class="n">p1_seg</span> <span class="o">=</span> <span class="n">unnorm_pd1</span>
        <span class="n">p2_seg</span> <span class="o">=</span> <span class="n">unnorm_pd2</span>

        <span class="c1"># If normalization has to be done interval by interval, do it here.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_common_mean</span><span class="p">:</span>
            <span class="n">mean1</span> <span class="o">=</span> <span class="n">n_ph1</span> <span class="o">/</span> <span class="n">n_bin</span>
            <span class="n">mean2</span> <span class="o">=</span> <span class="n">n_ph2</span> <span class="o">/</span> <span class="n">n_bin</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="n">n_bin</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">variance1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance1</span> <span class="o">*</span> <span class="n">variance2</span><span class="p">)</span>

            <span class="n">cs_seg</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                <span class="n">unnorm_power</span><span class="p">,</span>
                <span class="n">dt</span><span class="p">,</span>
                <span class="n">n_bin</span><span class="p">,</span>
                <span class="n">mean</span><span class="p">,</span>
                <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
                <span class="n">variance</span><span class="o">=</span><span class="n">variance</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
                <span class="n">p1_seg</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                    <span class="n">unnorm_pd1</span><span class="p">,</span>
                    <span class="n">dt</span><span class="p">,</span>
                    <span class="n">n_bin</span><span class="p">,</span>
                    <span class="n">mean1</span><span class="p">,</span>
                    <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph1</span><span class="p">,</span>
                    <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                    <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
                    <span class="n">variance</span><span class="o">=</span><span class="n">variance1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">p2_seg</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                    <span class="n">unnorm_pd2</span><span class="p">,</span>
                    <span class="n">dt</span><span class="p">,</span>
                    <span class="n">n_bin</span><span class="p">,</span>
                    <span class="n">mean2</span><span class="p">,</span>
                    <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph2</span><span class="p">,</span>
                    <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                    <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
                    <span class="n">variance</span><span class="o">=</span><span class="n">variance2</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
            <span class="n">subcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cs_seg</span><span class="p">)</span>
            <span class="n">unnorm_subcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unnorm_power</span><span class="p">)</span>

        <span class="c1"># Initialize or accumulate final averaged spectra</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">cross</span><span class="p">,</span> <span class="n">cs_seg</span><span class="p">)</span>
        <span class="n">unnorm_cross</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">unnorm_cross</span><span class="p">,</span> <span class="n">unnorm_power</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
            <span class="n">unnorm_pds1</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">unnorm_pds1</span><span class="p">,</span> <span class="n">unnorm_pd1</span><span class="p">)</span>
            <span class="n">unnorm_pds2</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">unnorm_pds2</span><span class="p">,</span> <span class="n">unnorm_pd2</span><span class="p">)</span>
            <span class="n">pds1</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">pds1</span><span class="p">,</span> <span class="n">p1_seg</span><span class="p">)</span>
            <span class="n">pds2</span> <span class="o">=</span> <span class="n">sum_if_not_none_or_initialize</span><span class="p">(</span><span class="n">pds2</span><span class="p">,</span> <span class="n">p2_seg</span><span class="p">)</span>

        <span class="n">n_ave</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># If no valid intervals were found, return only `None`s</span>
    <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Calculate the mean number of photons per chunk</span>
    <span class="n">n_ph1</span> <span class="o">=</span> <span class="n">sum_of_photons1</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="n">n_ph2</span> <span class="o">=</span> <span class="n">sum_of_photons2</span> <span class="o">/</span> <span class="n">n_ave</span>
    <span class="n">n_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_ph1</span> <span class="o">*</span> <span class="n">n_ph2</span><span class="p">)</span>

    <span class="c1"># Calculate the common mean number of photons per bin</span>
    <span class="n">common_mean1</span> <span class="o">=</span> <span class="n">n_ph1</span> <span class="o">/</span> <span class="n">n_bin</span>
    <span class="n">common_mean2</span> <span class="o">=</span> <span class="n">n_ph2</span> <span class="o">/</span> <span class="n">n_bin</span>
    <span class="n">common_mean</span> <span class="o">=</span> <span class="n">n_ph</span> <span class="o">/</span> <span class="n">n_bin</span>

    <span class="k">if</span> <span class="n">common_variance1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Note: the variances we summed were means, not sums. Hence M, not M*N</span>
        <span class="n">common_variance1</span> <span class="o">/=</span> <span class="n">n_ave</span>
        <span class="n">common_variance2</span> <span class="o">/=</span> <span class="n">n_ave</span>
        <span class="n">common_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">common_variance1</span> <span class="o">*</span> <span class="n">common_variance2</span><span class="p">)</span>

    <span class="c1"># Transform the sums into averages</span>
    <span class="n">cross</span> <span class="o">/=</span> <span class="n">n_ave</span>
    <span class="n">unnorm_cross</span> <span class="o">/=</span> <span class="n">n_ave</span>
    <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
        <span class="n">unnorm_pds1</span> <span class="o">/=</span> <span class="n">n_ave</span>
        <span class="n">unnorm_pds2</span> <span class="o">/=</span> <span class="n">n_ave</span>

    <span class="c1"># Finally, normalize the cross spectrum (only if not already done on an</span>
    <span class="c1"># interval-to-interval basis)</span>
    <span class="k">if</span> <span class="n">use_common_mean</span><span class="p">:</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
            <span class="n">unnorm_cross</span><span class="p">,</span>
            <span class="n">dt</span><span class="p">,</span>
            <span class="n">n_bin</span><span class="p">,</span>
            <span class="n">common_mean</span><span class="p">,</span>
            <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">variance</span><span class="o">=</span><span class="n">common_variance</span><span class="p">,</span>
            <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcs</span><span class="p">)):</span>
                <span class="n">subcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                    <span class="n">unnorm_subcs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">dt</span><span class="p">,</span>
                    <span class="n">n_bin</span><span class="p">,</span>
                    <span class="n">common_mean</span><span class="p">,</span>
                    <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph</span><span class="p">,</span>
                    <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                    <span class="n">variance</span><span class="o">=</span><span class="n">common_variance</span><span class="p">,</span>
                    <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
            <span class="n">pds1</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                <span class="n">unnorm_pds1</span><span class="p">,</span>
                <span class="n">dt</span><span class="p">,</span>
                <span class="n">n_bin</span><span class="p">,</span>
                <span class="n">common_mean1</span><span class="p">,</span>
                <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph1</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                <span class="n">variance</span><span class="o">=</span><span class="n">common_variance1</span><span class="p">,</span>
                <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">pds2</span> <span class="o">=</span> <span class="n">normalize_periodograms</span><span class="p">(</span>
                <span class="n">unnorm_pds2</span><span class="p">,</span>
                <span class="n">dt</span><span class="p">,</span>
                <span class="n">n_bin</span><span class="p">,</span>
                <span class="n">common_mean2</span><span class="p">,</span>
                <span class="n">n_ph</span><span class="o">=</span><span class="n">n_ph2</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                <span class="n">variance</span><span class="o">=</span><span class="n">common_variance2</span><span class="p">,</span>
                <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="c1"># If the user does not want negative frequencies, don&#39;t give them</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fullspec</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">fgt0</span><span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">Table</span><span class="p">()</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;unnorm_power&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_cross</span>
    <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="n">n_bin</span><span class="p">,</span>
            <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="n">n_ave</span><span class="p">,</span>
            <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="n">dt</span><span class="p">,</span>
            <span class="s2">&quot;norm&quot;</span><span class="p">:</span> <span class="n">norm</span><span class="p">,</span>
            <span class="s2">&quot;df&quot;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">),</span>
            <span class="s2">&quot;segment_size&quot;</span><span class="p">:</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">n_bin</span><span class="p">,</span>
            <span class="s2">&quot;nphots&quot;</span><span class="p">:</span> <span class="n">n_ph</span><span class="p">,</span>
            <span class="s2">&quot;nphots1&quot;</span><span class="p">:</span> <span class="n">n_ph1</span><span class="p">,</span>
            <span class="s2">&quot;nphots2&quot;</span><span class="p">:</span> <span class="n">n_ph2</span><span class="p">,</span>
            <span class="s2">&quot;countrate1&quot;</span><span class="p">:</span> <span class="n">common_mean1</span> <span class="o">/</span> <span class="n">dt</span><span class="p">,</span>
            <span class="s2">&quot;countrate2&quot;</span><span class="p">:</span> <span class="n">common_mean2</span> <span class="o">/</span> <span class="n">dt</span><span class="p">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">common_mean</span><span class="p">,</span>
            <span class="s2">&quot;mean1&quot;</span><span class="p">:</span> <span class="n">common_mean1</span><span class="p">,</span>
            <span class="s2">&quot;mean2&quot;</span><span class="p">:</span> <span class="n">common_mean2</span><span class="p">,</span>
            <span class="s2">&quot;power_type&quot;</span><span class="p">:</span> <span class="n">power_type</span><span class="p">,</span>
            <span class="s2">&quot;fullspec&quot;</span><span class="p">:</span> <span class="n">fullspec</span><span class="p">,</span>
            <span class="s2">&quot;variance&quot;</span><span class="p">:</span> <span class="n">common_variance</span><span class="p">,</span>
            <span class="s2">&quot;variance1&quot;</span><span class="p">:</span> <span class="n">common_variance1</span><span class="p">,</span>
            <span class="s2">&quot;variance2&quot;</span><span class="p">:</span> <span class="n">common_variance2</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">return_auxil</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;pds1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pds1</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;pds2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pds2</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;unnorm_pds1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_pds1</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;unnorm_pds2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unnorm_pds2</span>

    <span class="k">if</span> <span class="n">return_subcs</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;subcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subcs</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;unnorm_subcs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unnorm_subcs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_pds_from_events</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;avg_pds_from_events is deprecated, use avg_cs_from_timeseries instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">avg_pds_from_timeseries</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_pds_from_timeseries</span><span class="p">(</span>
    <span class="n">times</span><span class="p">,</span>
    <span class="n">gti</span><span class="p">,</span>
    <span class="n">segment_size</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span>
    <span class="n">use_common_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fluxes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">errors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_subcs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average periodogram from a list of event times or a light</span>
<span class="sd">    curve.</span>

<span class="sd">    If the input is a light curve, the time array needs to be uniformly sampled</span>
<span class="sd">    inside GTIs (it can have gaps outside), and the fluxes need to be passed</span>
<span class="sd">    through the ``fluxes`` array.</span>
<span class="sd">    Otherwise, times are interpreted as photon arrival times.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : float `np.array`</span>
<span class="sd">        Array of times.</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        Good time intervals.</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        Length of segments. If ``None``, the full light curve is used.</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the light curves used to produce periodograms.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    norm : str, default &quot;frac&quot;</span>
<span class="sd">        The normalization of the periodogram. &quot;abs&quot; is absolute rms, &quot;frac&quot; is</span>
<span class="sd">        fractional rms, &quot;leahy&quot; is Leahy+83 normalization, and &quot;none&quot; is the</span>
<span class="sd">        unnormalized periodogram</span>
<span class="sd">    use_common_mean : bool, default True</span>
<span class="sd">        The mean of the light curve can be estimated in each interval, or on</span>
<span class="sd">        the full light curve. This gives different results (Alston+2013).</span>
<span class="sd">        Here we assume the mean is calculated on the full light curve, but</span>
<span class="sd">        the user can set ``use_common_mean`` to False to calculate it on a</span>
<span class="sd">        per-segment basis.</span>
<span class="sd">    silent : bool, default False</span>
<span class="sd">        Silence the progress bars</span>
<span class="sd">    fluxes : float `np.array`, default None</span>
<span class="sd">        Array of counts per bin or fluxes</span>
<span class="sd">    errors : float `np.array`, default None</span>
<span class="sd">        Array of errors on the fluxes above</span>
<span class="sd">    return_subcs : bool, default False</span>
<span class="sd">        Return all sub spectra from each light curve chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freq : `np.array`</span>
<span class="sd">        The periodogram frequencies</span>
<span class="sd">    power : `np.array`</span>
<span class="sd">        The normalized periodogram powers</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        the number of bins in the light curves used in each segment</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        the number of averaged periodograms</span>
<span class="sd">    mean : float</span>
<span class="sd">        the mean flux</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binned</span> <span class="o">=</span> <span class="n">fluxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segment_size</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">=</span> <span class="n">fix_segment_size_to_integer_samples</span><span class="p">(</span><span class="n">segment_size</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">binned</span> <span class="ow">and</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">fluxes</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">=</span> <span class="n">fix_segment_size_to_integer_samples</span><span class="p">(</span><span class="n">gti</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">gti</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">dt</span><span class="p">)</span>

    <span class="n">flux_iterable</span> <span class="o">=</span> <span class="n">get_flux_iterable_from_segments</span><span class="p">(</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">n_bin</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">fluxes</span><span class="o">=</span><span class="n">fluxes</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span>
    <span class="p">)</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">avg_pds_from_iterable</span><span class="p">(</span>
        <span class="n">flux_iterable</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
        <span class="n">use_common_mean</span><span class="o">=</span><span class="n">use_common_mean</span><span class="p">,</span>
        <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
        <span class="n">return_subcs</span><span class="o">=</span><span class="n">return_subcs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">cross</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cross</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;gti&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gti</span>
    <span class="k">return</span> <span class="n">cross</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_cs_from_events</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;avg_cs_from_events is deprecated, use avg_cs_from_timeseries instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">avg_cs_from_timeseries</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">avg_cs_from_timeseries</span><span class="p">(</span>
    <span class="n">times1</span><span class="p">,</span>
    <span class="n">times2</span><span class="p">,</span>
    <span class="n">gti</span><span class="p">,</span>
    <span class="n">segment_size</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">,</span>
    <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;frac&quot;</span><span class="p">,</span>
    <span class="n">use_common_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">fullspec</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">power_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">fluxes1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fluxes2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">errors1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">errors2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_auxil</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_subcs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the average cross spectrum from a list of event times or a light</span>
<span class="sd">    curve.</span>

<span class="sd">    If the input is a light curve, the time arrays need to be uniformly sampled</span>
<span class="sd">    inside GTIs (they can have gaps outside), and the fluxes need to be passed</span>
<span class="sd">    through the ``fluxes1`` and ``fluxes2`` arrays.</span>
<span class="sd">    Otherwise, times are interpreted as photon arrival times</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times1 : float `np.array`</span>
<span class="sd">        Array of times in the sub-band</span>
<span class="sd">    times2 : float `np.array`</span>
<span class="sd">        Array of times in the reference band</span>
<span class="sd">    gti : [[gti00, gti01], [gti10, gti11], ...]</span>
<span class="sd">        common good time intervals</span>
<span class="sd">    segment_size : float</span>
<span class="sd">        length of segments. If ``None``, the full light curve is used.</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time resolution of the light curves used to produce periodograms</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    norm : str, default &quot;frac&quot;</span>
<span class="sd">        The normalization of the periodogram. &quot;abs&quot; is absolute rms, &quot;frac&quot; is</span>
<span class="sd">        fractional rms, &quot;leahy&quot; is Leahy+83 normalization, and &quot;none&quot; is the</span>
<span class="sd">        unnormalized periodogram</span>
<span class="sd">    use_common_mean : bool, default True</span>
<span class="sd">        The mean of the light curve can be estimated in each interval, or on</span>
<span class="sd">        the full light curve. This gives different results (Alston+2013).</span>
<span class="sd">        Here we assume the mean is calculated on the full light curve, but</span>
<span class="sd">        the user can set ``use_common_mean`` to False to calculate it on a</span>
<span class="sd">        per-segment basis.</span>
<span class="sd">    fullspec : bool, default False</span>
<span class="sd">        Return the full periodogram, including negative frequencies</span>
<span class="sd">    silent : bool, default False</span>
<span class="sd">        Silence the progress bars</span>
<span class="sd">    power_type : str, default &#39;all&#39;</span>
<span class="sd">        If &#39;all&#39;, give complex powers. If &#39;abs&#39;, the absolute value; if &#39;real&#39;,</span>
<span class="sd">        the real part</span>
<span class="sd">    fluxes1 : float `np.array`, default None</span>
<span class="sd">        Array of fluxes or counts per bin for channel 1</span>
<span class="sd">    fluxes2 : float `np.array`, default None</span>
<span class="sd">        Array of fluxes or counts per bin for channel 2</span>
<span class="sd">    errors1 : float `np.array`, default None</span>
<span class="sd">        Array of errors on the fluxes on channel 1</span>
<span class="sd">    errors2 : float `np.array`, default None</span>
<span class="sd">        Array of errors on the fluxes on channel 2</span>
<span class="sd">    return_subcs : bool, default False</span>
<span class="sd">        Return all sub spectra from each light curve chunk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freq : `np.array`</span>
<span class="sd">        The periodogram frequencies</span>
<span class="sd">    pds : `np.array`</span>
<span class="sd">        The normalized periodogram powers</span>
<span class="sd">    n_bin : int</span>
<span class="sd">        the number of bins in the light curves used in each segment</span>
<span class="sd">    n_ave : int</span>
<span class="sd">        the number of averaged periodograms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">binned</span> <span class="o">=</span> <span class="n">fluxes1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fluxes2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segment_size</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">=</span> <span class="n">fix_segment_size_to_integer_samples</span><span class="p">(</span><span class="n">segment_size</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">binned</span> <span class="ow">and</span> <span class="n">segment_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">fluxes1</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">=</span> <span class="n">fix_segment_size_to_integer_samples</span><span class="p">(</span><span class="n">gti</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">gti</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">dt</span><span class="p">)</span>

    <span class="n">flux_iterable1</span> <span class="o">=</span> <span class="n">get_flux_iterable_from_segments</span><span class="p">(</span>
        <span class="n">times1</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">n_bin</span><span class="o">=</span><span class="n">n_bin</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">fluxes</span><span class="o">=</span><span class="n">fluxes1</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors1</span>
    <span class="p">)</span>
    <span class="n">flux_iterable2</span> <span class="o">=</span> <span class="n">get_flux_iterable_from_segments</span><span class="p">(</span>
        <span class="n">times2</span><span class="p">,</span> <span class="n">gti</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">,</span> <span class="n">n_bin</span><span class="o">=</span><span class="n">n_bin</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">fluxes</span><span class="o">=</span><span class="n">fluxes2</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors2</span>
    <span class="p">)</span>

    <span class="n">is_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fluxes1</span><span class="p">,</span> <span class="n">fluxes2</span><span class="p">,</span> <span class="n">errors1</span><span class="p">,</span> <span class="n">errors2</span><span class="p">)])</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">is_events</span>
        <span class="ow">and</span> <span class="n">silent</span>
        <span class="ow">and</span> <span class="n">use_common_mean</span>
        <span class="ow">and</span> <span class="n">power_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">fullspec</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_auxil</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_subcs</span>
    <span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">avg_cs_from_iterables_quick</span><span class="p">(</span><span class="n">flux_iterable1</span><span class="p">,</span> <span class="n">flux_iterable2</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">avg_cs_from_iterables</span><span class="p">(</span>
            <span class="n">flux_iterable1</span><span class="p">,</span>
            <span class="n">flux_iterable2</span><span class="p">,</span>
            <span class="n">dt</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">use_common_mean</span><span class="o">=</span><span class="n">use_common_mean</span><span class="p">,</span>
            <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
            <span class="n">fullspec</span><span class="o">=</span><span class="n">fullspec</span><span class="p">,</span>
            <span class="n">power_type</span><span class="o">=</span><span class="n">power_type</span><span class="p">,</span>
            <span class="n">return_auxil</span><span class="o">=</span><span class="n">return_auxil</span><span class="p">,</span>
            <span class="n">return_subcs</span><span class="o">=</span><span class="n">return_subcs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;gti&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gti</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">lsft_fast</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">freqs</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">sign</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">oversampling</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Lomb-Scargle Fourier transform of a light curve.</span>
<span class="sd">    Only considers non-negative frequencies.</span>
<span class="sd">    Subtracts mean from data as it is required for the working of the algorithm.</span>

<span class="sd">    Adapted from original Matlab code by J. D. Scargle, using Astropy&#39;s ``trig_sum`` for speed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : a :class:`numpy.array` of floats</span>
<span class="sd">        Observations to be transformed.</span>

<span class="sd">    t : :class:`numpy.array` of floats</span>
<span class="sd">        Times of the observations</span>

<span class="sd">    freqs : :class:`numpy.array`</span>
<span class="sd">        An array of frequencies at which the transform is sampled.</span>

<span class="sd">    sign : int, optional, default: 1</span>
<span class="sd">        The sign of the fourier transform. 1 implies positive sign and -1 implies negative sign.</span>

<span class="sd">    fullspec : bool, optional, default: False</span>
<span class="sd">        Return LSFT values for full frequency array (True) or just positive frequencies (False).</span>

<span class="sd">    oversampling : float, optional, default: 5</span>
<span class="sd">        Interpolation Oversampling Factor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ft_res : numpy.ndarray</span>
<span class="sd">        An array of Fourier transformed data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y_</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Constants initialization</span>
    <span class="n">sum_xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>
    <span class="n">num_xt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>
    <span class="n">num_ww</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>

    <span class="c1"># Arrays initialization</span>
    <span class="n">ft_real</span> <span class="o">=</span> <span class="n">ft_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_ww</span><span class="p">))</span>
    <span class="n">f0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>

    <span class="c1"># Sum (y_i * cos(wt - wtau))</span>
    <span class="n">Sh</span><span class="p">,</span> <span class="n">Ch</span> <span class="o">=</span> <span class="n">trig_sum</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">)</span>

    <span class="c1"># Angular Frequency</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># Summation of cos(2wt) and sin(2wt)</span>
    <span class="n">csum</span><span class="p">,</span> <span class="n">ssum</span> <span class="o">=</span> <span class="n">trig_sum</span><span class="p">(</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_</span><span class="p">),</span> <span class="n">df</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">freq_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span>
    <span class="p">)</span>

    <span class="n">wtau</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ssum</span><span class="p">,</span> <span class="n">csum</span><span class="p">)</span>

    <span class="n">S2</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">trig_sum</span><span class="p">(</span>
        <span class="n">t</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y_</span><span class="p">),</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">N</span><span class="p">,</span>
        <span class="n">f0</span><span class="p">,</span>
        <span class="n">freq_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">oversampling</span><span class="o">=</span><span class="n">oversampling</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_ww</span><span class="p">)</span>

    <span class="n">coswtau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">wtau</span><span class="p">)</span>
    <span class="n">sinwtau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">wtau</span><span class="p">)</span>

    <span class="n">sumr</span> <span class="o">=</span> <span class="n">Ch</span> <span class="o">*</span> <span class="n">coswtau</span> <span class="o">+</span> <span class="n">Sh</span> <span class="o">*</span> <span class="n">sinwtau</span>
    <span class="n">sumi</span> <span class="o">=</span> <span class="n">Sh</span> <span class="o">*</span> <span class="n">coswtau</span> <span class="o">-</span> <span class="n">Ch</span> <span class="o">*</span> <span class="n">sinwtau</span>

    <span class="n">cos2wtau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wtau</span><span class="p">)</span>
    <span class="n">sin2wtau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">wtau</span><span class="p">)</span>

    <span class="n">scos2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">C2</span> <span class="o">*</span> <span class="n">cos2wtau</span> <span class="o">+</span> <span class="n">S2</span> <span class="o">*</span> <span class="n">sin2wtau</span><span class="p">)</span>
    <span class="n">ssin2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">C2</span> <span class="o">*</span> <span class="n">cos2wtau</span> <span class="o">-</span> <span class="n">S2</span> <span class="o">*</span> <span class="n">sin2wtau</span><span class="p">)</span>

    <span class="n">ft_real</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">sumr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scos2</span><span class="p">)</span>
    <span class="n">ft_imag</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span> <span class="o">*</span> <span class="n">sumi</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ssin2</span><span class="p">)</span>

    <span class="n">ft_real</span><span class="p">[</span><span class="n">freqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_xx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_xt</span><span class="p">)</span>
    <span class="n">ft_imag</span><span class="p">[</span><span class="n">freqs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">phase</span> <span class="o">=</span> <span class="n">wtau</span> <span class="o">-</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">ft_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">(</span><span class="n">ft_real</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">ft_imag</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ft_res</span>


<span class="k">def</span><span class="w"> </span><span class="nf">lsft_slow</span><span class="p">(</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">freqs</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">sign</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Lomb-Scargle Fourier transform of a light curve.</span>
<span class="sd">    Only considers non-negative frequencies.</span>
<span class="sd">    Subtracts mean from data as it is required for the working of the algorithm.</span>

<span class="sd">    Adapted from original Matlab code by J. D. Scargle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : a `:class:numpy.array` of floats</span>
<span class="sd">        Observations to be transformed.</span>

<span class="sd">    t : `:class:numpy.array` of floats</span>
<span class="sd">        Times of the observations</span>

<span class="sd">    freqs : numpy.ndarray</span>
<span class="sd">        An array of frequencies at which the transform is sampled.</span>

<span class="sd">    sign : int, optional, default: 1</span>
<span class="sd">        The sign of the fourier transform. 1 implies positive sign and -1 implies negative sign.</span>

<span class="sd">    fullspec : bool, optional, default: False</span>
<span class="sd">        Return LSFT values for full frequency array (True) or just positive frequencies (False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ft_res : numpy.ndarray</span>
<span class="sd">        An array of Fourier transformed data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y_</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">ft_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
    <span class="n">ft_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
    <span class="n">ft_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

    <span class="n">num_y</span> <span class="o">=</span> <span class="n">y_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sum_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span>
    <span class="n">const1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">num_y</span><span class="p">)</span>
    <span class="n">const2</span> <span class="o">=</span> <span class="n">const1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span>
    <span class="n">ft_real</span> <span class="o">=</span> <span class="n">ft_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_freqs</span><span class="p">)</span>
    <span class="n">ft_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_freqs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_freqs</span><span class="p">):</span>
        <span class="n">wrun</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="n">wrun</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ft_real</span> <span class="o">=</span> <span class="n">sum_y</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_y</span><span class="p">)</span>
            <span class="n">ft_imag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">phase_this</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculation of \omega \tau (II.5) --</span>
            <span class="n">csum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
            <span class="n">ssum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>

            <span class="n">watan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ssum</span><span class="p">,</span> <span class="n">csum</span><span class="p">)</span>
            <span class="n">wtau</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">watan</span>
            <span class="c1"># --</span>
            <span class="c1"># In the following, instead of t&#39;_n we are using \omega t&#39;_n = \omega t - \omega\tau</span>

            <span class="c1"># Terms of kind X_n * cos or sin (II.1) --</span>
            <span class="n">sumr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">wtau</span><span class="p">))</span>
            <span class="n">sumi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">wtau</span><span class="p">))</span>
            <span class="c1"># --</span>

            <span class="c1"># A and B before the square root and inversion in (II.3) --</span>
            <span class="n">scos2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">wtau</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">ssin2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">wtau</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

            <span class="c1"># const2 is const1 times the sign.</span>
            <span class="c1"># It&#39;s the F0 in II.2 without the phase factor</span>
            <span class="c1"># The sign decides whether we are calculating the direct or inverse transform</span>
            <span class="n">ft_real</span> <span class="o">=</span> <span class="n">const1</span> <span class="o">*</span> <span class="n">sumr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scos2</span><span class="p">)</span>
            <span class="n">ft_imag</span> <span class="o">=</span> <span class="n">const2</span> <span class="o">*</span> <span class="n">sumi</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ssin2</span><span class="p">)</span>

            <span class="n">phase_this</span> <span class="o">=</span> <span class="n">wtau</span> <span class="o">-</span> <span class="n">wrun</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ft_res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">(</span><span class="n">ft_real</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">ft_imag</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_this</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ft_res</span>


<span class="k">def</span><span class="w"> </span><span class="nf">impose_symmetry_lsft</span><span class="p">(</span>
    <span class="n">ft_res</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">sum_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">len_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">freqs</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Impose symmetry on the input fourier transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ft_res : np.array</span>
<span class="sd">        The Fourier transform of the signal.</span>
<span class="sd">    sum_y : float</span>
<span class="sd">        The sum of the values of the signal.</span>
<span class="sd">    len_y : int</span>
<span class="sd">        The length of the signal.</span>
<span class="sd">    freqs : np.array</span>
<span class="sd">        An array of frequencies at which the transform is sampled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lsft_res : np.array</span>
<span class="sd">        The Fourier transform of the signal with symmetry imposed.</span>
<span class="sd">    freqs_new : np.array</span>
<span class="sd">        The new frequencies</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ft_res_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">ft_res</span><span class="p">)),</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">ft_res</span><span class="p">])</span>
    <span class="n">freqs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="o">-</span><span class="n">freqs</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ft_res_new</span><span class="p">,</span> <span class="n">freqs_new</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2026, [{&#39;name&#39;: &#39;Stingray Developers&#39;, &#39;email&#39;: &#39;spectraltiming-stingray@googlegroups.com&#39;}].<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 8.1.3. &nbsp;
    Last built 01 Mar 2026. <br/>
  </p>
</footer>
  </body>
</html>